<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é­”åŸä¼èª¬ - Demon Castle Legend</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(45deg, #1a2e1a, #213e16);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: white;
        }
        
        .game-container {
            position: relative;
            border: 3px solid #00ff00;
            border-radius: 10px;
            box-shadow: 0 0 20px #00ff00;
            background: #000;
        }
        
        canvas {
            display: block;
            background: linear-gradient(180deg, #87CEEB, #228B22);
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        .ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ff00;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .controls {
            position: absolute;
            bottom: -100px;
            left: 0;
            right: 0;
            text-align: center;
            color: #aaa;
            font-size: 14px;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #ff6b6b;
            font-size: 24px;
            display: none;
        }
        
        .boss-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #ff0000;
            font-size: 36px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            display: none;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .music-control {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #00ff00;
            font-size: 14px;
            cursor: pointer;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .stage-info {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #ffff00;
            font-size: 28px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            display: none;
        }
        
        .title {
            position: absolute;
            top: -50px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffff00;
            font-size: 24px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="title">é­”åŸä¼èª¬é¢¨ç¸¦å‹æ­©è¡Œã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°</div>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="ui">
            <div>ã‚¹ã‚³ã‚¢: <span id="score">0</span></div>
            <div>HP: <span id="hp">100</span></div>
            <div>ãƒ¬ãƒ™ãƒ«: <span id="level">1</span></div>
            <div>ã‚¹ãƒ†ãƒ¼ã‚¸: <span id="stage">è‰åŸ</span></div>
            <div>æ­¦å™¨: <span id="weapon">é€šå¸¸å¼¾</span></div>
            <div>ãƒ¬ãƒ¼ã‚¶ãƒ¼: <span id="laser">0</span></div>
            <div id="speedMode" style="color: #ff0000; display: none;">ğŸš€ é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰</div>
        </div>
        <div class="music-control" id="musicToggle" onclick="toggleMusic()">ğŸµ BGM: ON</div>
        <div class="controls">
            çŸ¢å°ã‚­ãƒ¼: ç§»å‹• | ã‚¹ãƒšãƒ¼ã‚¹: å°„æ’ƒ | R: ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ | C: ã‚³ãƒ³ãƒ†ã‚£ãƒ‹ãƒ¥ãƒ¼<br>
            ï¼Ÿãƒœãƒƒã‚¯ã‚¹ã‚’æ’ƒã£ã¦æ­¦å™¨å¼·åŒ–ï¼é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰ã‚¢ã‚¤ãƒ†ãƒ ã§5ç§’é–“è¶…é«˜é€Ÿç§»å‹•ï¼<br>
            ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã‚‹ã¨æ­¦å™¨ãƒ¬ãƒ™ãƒ«ãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚æœ€å¤§HP: 60
        </div>
        <div class="game-over" id="gameOver">
            <div>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</div>
            <div style="font-size: 16px; margin-top: 10px;">Rã‚­ãƒ¼ã§ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</div>
        </div>
        <div class="boss-warning" id="bossWarning">
            <div>è­¦å‘Šï¼</div>
            <div style="font-size: 24px;">å¤ã®é­”ç‹é™è‡¨ï¼</div>
        </div>
        <div class="stage-info" id="stageInfo">
            <div id="stageText">æ–°ã‚¹ãƒ†ãƒ¼ã‚¸ï¼</div>
        </div>
        <div class="stage-info" id="endingScreen" style="color: #ffff00; font-size: 32px;">
            <div>ğŸ° é­”åŸä¼èª¬ ğŸ°</div>
            <div style="font-size: 24px; margin-top: 20px;">å‹‡è€…ãƒãƒãƒ­ãƒ³ã®å‹åˆ©ï¼</div>
            <div style="font-size: 18px; margin-top: 20px;">ğŸ‘¸ Princess Rescued! ğŸ‘¸</div>
            <div style="font-size: 16px; margin-top: 30px;">ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸï¼</div>
            <div style="font-size: 14px; margin-top: 20px;">Rã‚­ãƒ¼ã§ã‚‚ã†ä¸€åº¦éŠã¶</div>
        </div>
        <div class="stage-info" id="continueScreen" style="color: #ffff00; font-size: 28px;">
            <div>ğŸ’€ CONTINUE? ğŸ’€</div>
            <div style="font-size: 20px; margin-top: 20px;" id="continueCount">æ®‹ã‚Šå›æ•°: 5</div>
            <div style="font-size: 16px; margin-top: 30px;">
                Cã‚­ãƒ¼: ã‚³ãƒ³ãƒ†ã‚£ãƒ‹ãƒ¥ãƒ¼<br>
                Rã‚­ãƒ¼: æœ€åˆã‹ã‚‰ã‚„ã‚Šç›´ã—
            </div>
            <div style="font-size: 14px; margin-top: 20px; color: #aaa;">10ç§’ã§ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</div>
        </div>
        <div class="stage-info" id="startScreen" style="color: #00ff00; font-size: 36px;">
            <div>ğŸ° é­”åŸä¼èª¬ ğŸ°</div>
            <div style="font-size: 20px; margin-top: 20px;">Demon Castle Legend</div>
            <div style="font-size: 16px; margin-top: 30px;">ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§ã‚¹ã‚¿ãƒ¼ãƒˆ</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ãƒ‰ãƒƒãƒˆçµµã‚¹ãƒ—ãƒ©ã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ï¼ˆ16x16ãƒ”ã‚¯ã‚»ãƒ«ï¼‰
        const spriteData = {
            // ãƒãƒãƒ­ãƒ³ï¼ˆé­”åŸä¼èª¬é¢¨ã®é‡åšãªé§æˆ¦å£«ãƒ»å¾Œã‚å§¿ãƒ»è§’ä»˜ããƒ˜ãƒ«ãƒ¡ãƒƒãƒˆï¼‰
            popolon: [
                [0,0,0,17,17,4,4,4,4,4,4,17,17,0,0,0],
                [0,0,17,17,4,4,4,4,4,4,4,4,17,17,0,0],
                [0,17,4,4,4,4,4,4,4,4,4,4,4,4,17,0],
                [17,4,4,18,18,4,4,4,4,4,4,18,18,4,4,17],
                [4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,4],
                [4,2,11,11,11,2,2,2,2,2,2,11,11,2,4],
                [4,2,2,11,2,2,2,2,2,2,2,2,11,2,2,4],
                [4,2,2,2,2,2,14,14,14,14,2,2,2,2,2,4],
                [0,4,2,2,2,14,14,14,14,14,14,2,2,2,4,0],
                [0,4,4,2,2,14,14,19,19,14,14,2,2,4,4,0],
                [0,0,4,4,4,14,14,14,14,14,14,4,4,4,0,0],
                [0,0,4,4,14,14,19,0,0,19,14,14,4,4,0,0],
                [0,4,4,4,14,14,0,0,0,0,14,14,4,4,4,0],
                [4,4,4,4,4,4,0,0,0,0,4,4,4,4,4,4],
                [4,4,4,4,4,0,0,0,0,0,0,4,4,4,4,4],
                [4,4,4,4,0,0,0,0,0,0,0,0,4,4,4,4]
            ],
            // é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰ç”¨ãƒãƒãƒ­ãƒ³ï¼ˆèµ¤ã„é‡åšé§æˆ¦å£«ãƒ»å¾Œã‚å§¿ãƒ»è§’ä»˜ããƒ˜ãƒ«ãƒ¡ãƒƒãƒˆï¼‰
            popolon_speed: [
                [0,0,0,17,17,4,4,4,4,4,4,17,17,0,0,0],
                [0,0,17,17,4,4,4,4,4,4,4,4,17,17,0,0],
                [0,17,4,4,4,4,4,4,4,4,4,4,4,4,17,0],
                [17,4,4,18,18,4,4,4,4,4,4,18,18,4,4,17],
                [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4],
                [4,3,15,15,15,3,3,3,3,3,3,15,15,3,4],
                [4,3,3,15,3,3,3,3,3,3,3,3,15,3,3,4],
                [4,3,3,3,3,3,16,16,16,16,3,3,3,3,3,4],
                [0,4,3,3,3,16,16,16,16,16,16,3,3,3,4,0],
                [0,4,4,3,3,16,16,20,20,16,16,3,3,4,4,0],
                [0,0,4,4,4,16,16,16,16,16,16,4,4,4,0,0],
                [0,0,4,4,16,16,20,0,0,20,16,16,4,4,0,0],
                [0,4,4,4,16,16,0,0,0,0,16,16,4,4,4,0],
                [4,4,4,4,4,4,0,0,0,0,4,4,4,4,4,4],
                [4,4,4,4,4,0,0,0,0,0,0,4,4,4,4,4],
                [4,4,4,4,0,0,0,0,0,0,0,0,4,4,4,4]
            ],
            // ã‚³ã‚¦ãƒ¢ãƒª - ç”»åƒ3ã‚’å‚è€ƒã«ä¿®æ­£ï¼ˆé»’ã„ä½“ã€èµ¤ã„ç›®ï¼‰
            bat: [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0],
                [1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1],
                [1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                [0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],
                [0,0,0,0,1,3,1,1,1,1,3,1,0,0,0,0],
                [0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0],
                [0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ],
            // ï¼Ÿãƒœãƒƒã‚¯ã‚¹ - ç°è‰²ãƒ–ãƒ­ãƒƒã‚¯ã«é»’æ–‡å­—ã®ï¼Ÿ
            questionBox: [
                [8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8],
                [8,12,12,12,12,12,12,12,12,12,12,12,12,12,12,8],
                [8,12,12,12,12,12,12,12,12,12,12,12,12,12,12,8],
                [8,12,12,0,0,0,0,0,0,0,0,0,0,12,12,8],
                [8,12,12,0,12,12,12,12,12,12,12,0,0,12,12,8],
                [8,12,12,0,12,12,12,12,12,12,12,0,0,12,12,8],
                [8,12,12,0,0,0,0,0,0,12,12,0,0,12,12,8],
                [8,12,12,0,0,0,0,12,12,12,12,0,0,12,12,8],
                [8,12,12,0,0,0,12,12,12,0,0,0,0,12,12,8],
                [8,12,12,0,0,0,12,12,0,0,0,0,0,12,12,8],
                [8,12,12,0,0,0,0,0,0,0,0,0,0,12,12,8],
                [8,12,12,0,0,0,12,12,12,0,0,0,0,12,12,8],
                [8,12,12,12,12,12,12,12,12,12,12,12,12,12,12,8],
                [8,12,12,12,12,12,12,12,12,12,12,12,12,12,12,8],
                [8,13,13,13,13,13,13,13,13,13,13,13,13,13,13,8],
                [8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]
            ],
            // ãƒ¡ãƒ‡ãƒ¥ãƒ¼ã‚µï¼ˆãƒœã‚¹ï¼‰- ç”»åƒ5ã‚’å‚è€ƒã«è¿½åŠ 
            medusa: [
                [0,0,0,9,9,9,9,9,9,9,9,9,9,0,0,0],
                [0,9,9,9,9,9,9,9,9,9,9,9,9,9,9,0],
                [9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9],
                [9,9,5,5,9,9,9,9,9,9,9,9,5,5,9,9],
                [9,9,5,3,9,9,9,9,9,9,9,9,5,3,9,9],
                [9,9,9,9,9,9,5,5,5,5,9,9,9,9,9,9],
                [9,9,9,9,9,5,5,1,1,5,5,9,9,9,9,9],
                [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10],
                [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10],
                [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10],
                [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10],
                [0,10,10,10,10,10,10,10,10,10,10,10,10,10,10,0],
                [0,0,10,10,10,10,10,10,10,10,10,10,10,10,0,0],
                [0,0,0,10,10,10,10,10,10,10,10,10,10,0,0,0],
                [0,0,0,0,10,10,10,10,10,10,10,10,0,0,0,0],
                [0,0,0,0,0,10,10,10,10,10,10,0,0,0,0,0]
            ]
        };
        
        // ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ
        const colors = {
            0: '#000000', // é»’
            1: '#333333', // æ¿ƒã„ã‚°ãƒ¬ãƒ¼ï¼ˆã‚³ã‚¦ãƒ¢ãƒªã®ä½“ï¼‰
            2: '#4169E1', // æ°´è‰²ã®é§ï¼ˆãƒãƒãƒ­ãƒ³ã®ãƒ¡ã‚¤ãƒ³ï¼‰
            3: '#FF0000', // èµ¤ï¼ˆç›®ã€é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰ï¼‰
            4: '#8B4513', // èŒ¶è‰²ï¼ˆãƒãƒãƒ­ãƒ³ã®é«ªãƒ»é©ï¼‰
            5: '#FFE4C4', // è‚Œè‰²
            6: '#FFD700', // é‡‘è‰²ï¼ˆï¼Ÿãƒœãƒƒã‚¯ã‚¹å¤–æ ï¼‰
            7: '#FFA500', // ã‚ªãƒ¬ãƒ³ã‚¸ï¼ˆï¼Ÿãƒœãƒƒã‚¯ã‚¹å†…å´ï¼‰
            8: '#696969', // ãƒ€ãƒ¼ã‚¯ã‚°ãƒ¬ãƒ¼ï¼ˆï¼Ÿãƒœãƒƒã‚¯ã‚¹å¤–æ ï¼‰
            9: '#228B22', // ç·‘ï¼ˆãƒ¡ãƒ‡ãƒ¥ãƒ¼ã‚µã®é«ªãƒ»è›‡ï¼‰
            10: '#DC143C', // æ·±ç´…ï¼ˆãƒ¡ãƒ‡ãƒ¥ãƒ¼ã‚µã®æœï¼‰
            11: '#87CEEB',  // æ˜ã‚‹ã„æ°´è‰²ï¼ˆé§ã®è£…é£¾ï¼‰
            12: '#C0C0C0', // ãƒ©ã‚¤ãƒˆã‚°ãƒ¬ãƒ¼ï¼ˆï¼Ÿãƒœãƒƒã‚¯ã‚¹å†…å´ï¼‰
            13: '#808080', // ã‚°ãƒ¬ãƒ¼ï¼ˆï¼Ÿãƒœãƒƒã‚¯ã‚¹å½±ï¼‰
            14: '#1E90FF', // é®®ã‚„ã‹ãªé’ï¼ˆé§ã®ä¸­å¤®éƒ¨ï¼‰
            15: '#FF6B6B', // æ˜ã‚‹ã„èµ¤ï¼ˆé«˜é€Ÿãƒ¢ãƒ¼ãƒ‰é§è£…é£¾ï¼‰
            16: '#FF1493', // æ·±ã„ãƒ”ãƒ³ã‚¯ï¼ˆé«˜é€Ÿãƒ¢ãƒ¼ãƒ‰é§ä¸­å¤®ï¼‰
            17: '#D2691E', // ãƒ–ãƒ­ãƒ³ã‚ºï¼ˆãƒ˜ãƒ«ãƒ¡ãƒƒãƒˆã®è§’ï¼‰
            18: '#C0C0C0', // ã‚·ãƒ«ãƒãƒ¼ï¼ˆãƒ˜ãƒ«ãƒ¡ãƒƒãƒˆè£…é£¾ï¼‰
            19: '#FFD700', // ã‚´ãƒ¼ãƒ«ãƒ‰ï¼ˆé§ã®è£…é£¾ï¼‰
            20: '#FFA500'  // ã‚ªãƒ¬ãƒ³ã‚¸ã‚´ãƒ¼ãƒ«ãƒ‰ï¼ˆé«˜é€Ÿãƒ¢ãƒ¼ãƒ‰è£…é£¾ï¼‰
        };
        
        // BGMã‚·ã‚¹ãƒ†ãƒ  - å„ãƒœã‚¹å°‚ç”¨BGMè¿½åŠ 
        let normalSynth, normalBass, normalDrums, normalArpeggio, normalLead;
        let boss1Synth, boss1Bass, boss1Drums, boss1Lead; // 1ä½“ç›®ãƒœã‚¹ç”¨
        let boss2Synth, boss2Bass, boss2Drums, boss2Lead; // 2ä½“ç›®ãƒœã‚¹ç”¨
        let boss3Synth, boss3Bass, boss3Drums, boss3Lead; // 3ä½“ç›®ãƒœã‚¹ç”¨ï¼ˆæœ€çµ‚ãƒœã‚¹ï¼‰
        let startSynth, startLead, startBass; // ã‚¹ã‚¿ãƒ¼ãƒˆBGMç”¨
        let victorySynth, victoryLead, victoryBass; // å‹åˆ©BGMç”¨
        let shootSE, enemyHitSE, enemyDeathSE, itemGetSE, weaponUpSE, powerItemSE, healthItemSE, laserAmmoSE, playerDamageSE, playerDamageSE2, playerDamageSE3;
        let enemyKillSE1, enemyKillSE2, enemyKillSE3, speedModeActivateSE, questionBoxSE; // ?ãƒœãƒƒã‚¯ã‚¹SEè¿½åŠ 
        let musicStarted = false, musicEnabled = true, isBoss1Music = false, isBoss2Music = false, isBoss3Music = false, isStartMusic = false, isVictoryMusic = false;
        let startMusicTimer = 0;
        
        async function initializeMusic() {
            if (musicStarted) return;
            
            try {
                await Tone.start();
                console.log("Tone.js started successfully");
                
                // ã‚¼ãƒ“ã‚¦ã‚¹é¢¨ã‚¹ã‚¿ãƒ¼ãƒˆBGM
                startSynth = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.08, decay: 0.2, sustain: 0.7, release: 0.4 },
                    volume: -4
                }).toDestination();
                
                startLead = new Tone.Synth({
                    oscillator: { type: "square" },
                    envelope: { attack: 0.05, decay: 0.15, sustain: 0.5, release: 0.3 },
                    volume: -6
                }).toDestination();
                
                startBass = new Tone.Synth({
                    oscillator: { type: "sawtooth" },
                    envelope: { attack: 0.02, decay: 0.3, sustain: 0.6, release: 0.5 },
                    volume: -8
                }).toDestination();
                
                // å‹åˆ©BGM
                victorySynth = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.05, decay: 0.2, sustain: 0.8, release: 0.6 },
                    volume: -2
                }).toDestination();
                
                victoryLead = new Tone.Synth({
                    oscillator: { type: "square" },
                    envelope: { attack: 0.03, decay: 0.18, sustain: 0.6, release: 0.4 },
                    volume: -4
                }).toDestination();
                
                victoryBass = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: { attack: 0.08, decay: 0.25, sustain: 0.7, release: 0.8 },
                    volume: -6
                }).toDestination();
                
                // å‹‡æ•¢ã§ç››ã‚Šä¸ŠãŒã‚‹BGMæ§‹æˆ
                normalSynth = new Tone.Synth({
                    oscillator: { type: "square" },
                    envelope: { attack: 0.03, decay: 0.1, sustain: 0.6, release: 0.2 },
                    volume: -8
                }).toDestination();
                
                normalLead = new Tone.Synth({
                    oscillator: { type: "sawtooth" },
                    envelope: { attack: 0.05, decay: 0.15, sustain: 0.4, release: 0.25 },
                    volume: -10
                }).toDestination();
                
                normalArpeggio = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.08, decay: 0.12, sustain: 0.3, release: 0.2 },
                    volume: -12
                }).toDestination();
                
                normalBass = new Tone.Synth({
                    oscillator: { type: "sawtooth" },
                    envelope: { attack: 0.02, decay: 0.2, sustain: 0.5, release: 0.4 },
                    volume: -10
                }).toDestination();
                
                normalDrums = new Tone.NoiseSynth({
                    noise: { type: "white" },
                    envelope: { attack: 0.003, decay: 0.08, sustain: 0.05, release: 0.08 },
                    volume: -18
                }).toDestination();
                
                // ãƒœã‚¹BGMï¼ˆã•ã‚‰ã«è¿«åŠ›æº€ç‚¹ï¼‰
                bossSynth = new Tone.Synth({
                    oscillator: { type: "square" },
                    envelope: { attack: 0.02, decay: 0.25, sustain: 0.7, release: 0.3 },
                    volume: -6
                }).toDestination();
                
                bossLead = new Tone.Synth({
                    oscillator: { type: "sawtooth" },
                    envelope: { attack: 0.03, decay: 0.18, sustain: 0.6, release: 0.25 },
                    volume: -8
                }).toDestination();
                
                bossBass = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.02, decay: 0.3, sustain: 0.5, release: 0.5 },
                    volume: -10
                }).toDestination();
                
                // 1ä½“ç›®ãƒœã‚¹BGM
                boss1Synth = new Tone.Synth({
                    oscillator: { type: "square" },
                    envelope: { attack: 0.02, decay: 0.25, sustain: 0.7, release: 0.3 },
                    volume: -6
                }).toDestination();
                
                boss1Lead = new Tone.Synth({
                    oscillator: { type: "sawtooth" },
                    envelope: { attack: 0.03, decay: 0.18, sustain: 0.6, release: 0.25 },
                    volume: -8
                }).toDestination();
                
                boss1Bass = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.02, decay: 0.3, sustain: 0.5, release: 0.5 },
                    volume: -10
                }).toDestination();
                
                boss1Drums = new Tone.NoiseSynth({
                    noise: { type: "pink" },
                    envelope: { attack: 0.005, decay: 0.15, sustain: 0.08, release: 0.12 },
                    volume: -13
                }).toDestination();
                
                // 2ä½“ç›®ãƒœã‚¹BGM
                boss2Synth = new Tone.Synth({
                    oscillator: { type: "sawtooth" },
                    envelope: { attack: 0.01, decay: 0.3, sustain: 0.8, release: 0.4 },
                    volume: -5
                }).toDestination();
                
                boss2Lead = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.02, decay: 0.2, sustain: 0.7, release: 0.3 },
                    volume: -7
                }).toDestination();
                
                boss2Bass = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: { attack: 0.01, decay: 0.4, sustain: 0.6, release: 0.6 },
                    volume: -9
                }).toDestination();
                
                boss2Drums = new Tone.NoiseSynth({
                    noise: { type: "brown" },
                    envelope: { attack: 0.003, decay: 0.2, sustain: 0.1, release: 0.15 },
                    volume: -12
                }).toDestination();
                
                // 3ä½“ç›®ãƒœã‚¹BGMï¼ˆæœ€çµ‚ãƒœã‚¹ï¼‰
                boss3Synth = new Tone.Synth({
                    oscillator: { type: "sawtooth" },
                    envelope: { attack: 0.01, decay: 0.3, sustain: 0.8, release: 0.4 },
                    volume: -4
                }).toDestination();
                
                boss3Lead = new Tone.Synth({
                    oscillator: { type: "square" },
                    envelope: { attack: 0.02, decay: 0.2, sustain: 0.7, release: 0.3 },
                    volume: -6
                }).toDestination();
                
                boss3Bass = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.01, decay: 0.4, sustain: 0.6, release: 0.6 },
                    volume: -8
                }).toDestination();
                
                boss3Drums = new Tone.NoiseSynth({
                    noise: { type: "white" },
                    envelope: { attack: 0.002, decay: 0.2, sustain: 0.1, release: 0.15 },
                    volume: -10
                }).toDestination();
                
                // SEï¼ˆé­”åŸä¼èª¬é¢¨ï¼‰
                shootSE = new Tone.Synth({
                    oscillator: { type: "square" },
                    envelope: { attack: 0.002, decay: 0.05, sustain: 0, release: 0.05 },
                    volume: -10
                }).toDestination();
                
                enemyHitSE = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: { attack: 0.008, decay: 0.1, sustain: 0, release: 0.06 },
                    volume: -8
                }).toDestination();
                
                enemyDeathSE = new Tone.NoiseSynth({
                    noise: { type: "brown" },
                    envelope: { attack: 0.002, decay: 0.15, sustain: 0, release: 0.1 },
                    volume: -6
                }).toDestination();
                
                // ?ãƒœãƒƒã‚¯ã‚¹ç ´å£ŠSEï¼ˆçˆ½å¿«æ„Ÿã®ã‚ã‚‹éŸ³ï¼‰
                questionBoxSE = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.3 },
                    volume: -4
                }).toDestination();
                
                // é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰ç™ºå‹•SE
                speedModeActivateSE = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.01, decay: 0.3, sustain: 0.2, release: 0.5 },
                    volume: -2
                }).toDestination();
                
                // æ•µæ’ƒç ´çˆ½å¿«SEï¼ˆè¤‡åˆéŸ³ã§æ°—æŒã¡ã‚ˆã•ã‚¢ãƒƒãƒ—ï¼‰
                enemyKillSE1 = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.005, decay: 0.2, sustain: 0.15, release: 0.25 },
                    volume: -4
                }).toDestination();
                
                enemyKillSE2 = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: { attack: 0.008, decay: 0.18, sustain: 0.12, release: 0.3 },
                    volume: -6
                }).toDestination();
                
                enemyKillSE3 = new Tone.Synth({
                    oscillator: { type: "square" },
                    envelope: { attack: 0.003, decay: 0.1, sustain: 0.08, release: 0.15 },
                    volume: -8
                }).toDestination();
                
                // ãƒãƒãƒ­ãƒ³ãƒ€ãƒ¡ãƒ¼ã‚¸SEï¼ˆç—›ã¿ã‚’è¡¨ç¾ï¼‰ - å¼·åŒ–ç‰ˆ
                playerDamageSE = new Tone.Synth({
                    oscillator: { type: "sawtooth" },
                    envelope: { attack: 0.001, decay: 0.12, sustain: 0.08, release: 0.15 },
                    volume: -2
                }).toDestination();
                
                // è¿½åŠ ã®ãƒ€ãƒ¡ãƒ¼ã‚¸SEï¼ˆé‡ã­ã¦ç—›ã¿ã‚’å¼·èª¿ï¼‰ - å¼·åŒ–ç‰ˆ
                playerDamageSE2 = new Tone.NoiseSynth({
                    noise: { type: "pink" },
                    envelope: { attack: 0.001, decay: 0.06, sustain: 0, release: 0.08 },
                    volume: -6
                }).toDestination();
                
                // ç¬¬3ã®ãƒ€ãƒ¡ãƒ¼ã‚¸SEï¼ˆã•ã‚‰ã«ç—›ã¿ã‚’å¼·èª¿ï¼‰
                playerDamageSE3 = new Tone.Synth({
                    oscillator: { type: "square" },
                    envelope: { attack: 0.003, decay: 0.1, sustain: 0.05, release: 0.12 },
                    volume: -8
                }).toDestination();
                
                itemGetSE = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.008, decay: 0.12, sustain: 0.08, release: 0.2 },
                    volume: -6
                }).toDestination();
                
                powerItemSE = new Tone.Synth({
                    oscillator: { type: "sawtooth" },
                    envelope: { attack: 0.015, decay: 0.2, sustain: 0.12, release: 0.25 },
                    volume: -6
                }).toDestination();
                
                healthItemSE = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: { attack: 0.015, decay: 0.25, sustain: 0.15, release: 0.35 },
                    volume: -6
                }).toDestination();
                
                laserAmmoSE = new Tone.Synth({
                    oscillator: { type: "square" },
                    envelope: { attack: 0.008, decay: 0.15, sustain: 0.08, release: 0.25 },
                    volume: -6
                }).toDestination();
                
                weaponUpSE = new Tone.Synth({
                    oscillator: { type: "sawtooth" },
                    envelope: { attack: 0.015, decay: 0.35, sustain: 0.25, release: 0.4 },
                    volume: -4
                }).toDestination();
                
                musicStarted = true;
                console.log("Epic hero music initialized successfully");
            } catch (error) {
                console.error("Failed to initialize music:", error);
            }
        }
        
        function startZeviousMusic() {
            try {
                if (!isStartMusic) return;
                
                Tone.Transport.cancel();
                console.log("Starting Zevious-style opening music");
                
                // ã‚¼ãƒ“ã‚¦ã‚¹é¢¨ã®ã‚ªãƒ¼ãƒ—ãƒ‹ãƒ³ã‚°ï¼ˆ8ç§’é–“ï¼‰
                const openingMelody = ["C4", "D4", "E4", "F4", "G4", "A4", "B4", "C5", "B4", "A4", "G4", "F4"];
                const openingLead = ["E4", "F4", "G4", "A4", "B4", "C5", "D5", "E5", "D5", "C5", "B4", "A4"];
                const openingBass = ["C3", "C3", "F3", "F3", "G3", "G3", "C3", "C3"];
                
                let melodyIndex = 0;
                let leadIndex = 0;
                let bassIndex = 0;
                
                // ãƒ•ã‚¡ãƒ³ãƒ•ã‚¡ãƒ¼ãƒ¬ãƒ¡ãƒ­ãƒ‡ã‚£
                Tone.Transport.scheduleRepeat((time) => {
                    if (musicEnabled && isStartMusic && startSynth) {
                        startSynth.triggerAttackRelease(openingMelody[melodyIndex % openingMelody.length], "4n", time);
                        melodyIndex++;
                    }
                }, "4n");
                
                // å£®å¤§ãªãƒªãƒ¼ãƒ‰
                Tone.Transport.scheduleRepeat((time) => {
                    if (musicEnabled && isStartMusic && startLead) {
                        startLead.triggerAttackRelease(openingLead[leadIndex % openingLead.length], "2n", time);
                        leadIndex++;
                    }
                }, "2n");
                
                // åŠ›å¼·ã„ãƒ™ãƒ¼ã‚¹
                Tone.Transport.scheduleRepeat((time) => {
                    if (musicEnabled && isStartMusic && startBass) {
                        startBass.triggerAttackRelease(openingBass[bassIndex % openingBass.length], "2n", time);
                        bassIndex++;
                    }
                }, "2n");
                
                Tone.Transport.bpm.value = 120; // è˜å³ãªãƒ†ãƒ³ãƒ
                Tone.Transport.start();
                
                // 8ç§’å¾Œã«é€šå¸¸BGMã«åˆ‡ã‚Šæ›¿ãˆ
                startMusicTimer = 480; // 60fps * 8ç§’
            } catch (e) {
                console.warn('Error starting opening music:', e);
            }
        }
        
        function startVictoryMusic() {
            try {
                if (!isVictoryMusic) return;
                
                Tone.Transport.cancel();
                console.log("Starting happy ending celebration music");
                
                // ãƒãƒƒãƒ”ãƒ¼ãªã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°BGMï¼ˆç¶™ç¶šçš„ã«æµã‚Œã‚‹ï¼‰
                const happyMelody = ["C5", "D5", "E5", "C5", "E5", "G5", "E5", "D5", "C5", "D5", "E5", "G5"];
                const happyLead = ["G5", "A5", "B5", "C6", "B5", "A5", "G5", "F5", "E5", "F5", "G5", "A5"];
                const happyBass = ["C3", "F3", "G3", "C3", "F3", "G3", "C3", "Am3"];
                
                let victoryIndex = 0;
                let victoryLeadIndex = 0;
                let victoryBassIndex = 0;
                
                // ãƒãƒƒãƒ”ãƒ¼ãƒ¡ãƒ­ãƒ‡ã‚£
                Tone.Transport.scheduleRepeat((time) => {
                    if (musicEnabled && isVictoryMusic && victorySynth) {
                        victorySynth.triggerAttackRelease(happyMelody[victoryIndex % happyMelody.length], "4n", time);
                        victoryIndex++;
                    }
                }, "4n");
                
                // ãƒãƒƒãƒ”ãƒ¼ãƒªãƒ¼ãƒ‰
                Tone.Transport.scheduleRepeat((time) => {
                    if (musicEnabled && isVictoryMusic && victoryLead) {
                        victoryLead.triggerAttackRelease(happyLead[victoryLeadIndex % happyLead.length], "2n", time);
                        victoryLeadIndex++;
                    }
                }, "2n");
                
                // ãƒãƒƒãƒ”ãƒ¼ãƒ™ãƒ¼ã‚¹
                Tone.Transport.scheduleRepeat((time) => {
                    if (musicEnabled && isVictoryMusic && victoryBass) {
                        victoryBass.triggerAttackRelease(happyBass[victoryBassIndex % happyBass.length], "1n", time);
                        victoryBassIndex++;
                    }
                }, "1n");
                
                Tone.Transport.bpm.value = 160; // æ˜ã‚‹ãæ¥½ã—ã„ãƒ†ãƒ³ãƒ
                Tone.Transport.start();
                
                // ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°BGMã¯ç¶™ç¶šã—ã¦æµã‚Œã‚‹ï¼ˆã‚¿ã‚¤ãƒãƒ¼ãªã—ï¼‰
            } catch (e) {
                console.warn('Error starting victory music:', e);
            }
        }
        
        function startEpicMusic() {
            if (isBossMusic || isStartMusic || isVictoryMusic || isFinalBossMusic) return;
            
            Tone.Transport.cancel();
            console.log("Starting epic hero music");
            
            // å‹‡æ•¢ã§ç››ã‚Šä¸ŠãŒã‚‹ãƒ¡ãƒ­ãƒ‡ã‚£ - ãƒ†ãƒ³ã‚·ãƒ§ãƒ³é«˜ã‚
            const heroicMelody = ["G4", "A4", "B4", "C5", "D5", "E5", "D5", "C5", "B4", "C5", "D5", "G4"];
            const leadMelody = ["E5", "D5", "C5", "B4", "C5", "D5", "E5", "G5", "F#5", "E5", "D5", "C5"];
            const arpeggioPattern = ["G3", "B3", "D4", "G4", "D4", "B3", "C4", "E4", "G4", "E4", "C4", "D4"];
            const heroicBass = ["G2", "G2", "C3", "C3", "D3", "D3", "G2", "G2"];
            
            let heroIndex = 0;
            let leadIndex = 0;
            let arpeggioIndex = 0;
            let bassIndex = 0;
            
            // ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ­ãƒ‡ã‚£ï¼ˆå‹‡æ•¢ï¼‰
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && !isBossMusic && !isStartMusic && !isVictoryMusic && !isFinalBossMusic && normalSynth) {
                    normalSynth.triggerAttackRelease(heroicMelody[heroIndex % heroicMelody.length], "8n", time);
                    heroIndex++;
                }
            }, "8n");
            
            // ãƒªãƒ¼ãƒ‰ãƒ¡ãƒ­ãƒ‡ã‚£ï¼ˆç››ã‚Šä¸ŠãŒã‚Šï¼‰
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && !isBossMusic && !isStartMusic && !isVictoryMusic && !isFinalBossMusic && normalLead) {
                    normalLead.triggerAttackRelease(leadMelody[leadIndex % leadMelody.length], "4n", time);
                    leadIndex++;
                }
            }, "4n");
            
            // ã‚¢ãƒ«ãƒšã‚¸ã‚ªï¼ˆèºå‹•æ„Ÿï¼‰
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && !isBossMusic && !isStartMusic && !isVictoryMusic && !isFinalBossMusic && normalArpeggio) {
                    normalArpeggio.triggerAttackRelease(arpeggioPattern[arpeggioIndex % arpeggioPattern.length], "16n", time);
                    arpeggioIndex++;
                }
            }, "16n");
            
            // åŠ›å¼·ã„ãƒ™ãƒ¼ã‚¹
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && !isBossMusic && !isStartMusic && !isVictoryMusic && !isFinalBossMusic && normalBass) {
                    normalBass.triggerAttackRelease(heroicBass[bassIndex % heroicBass.length], "4n", time);
                    bassIndex++;
                }
            }, "4n");
            
            // èºå‹•æ„Ÿã®ã‚ã‚‹ãƒ‰ãƒ©ãƒ 
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && !isBossMusic && !isStartMusic && !isVictoryMusic && !isFinalBossMusic && normalDrums) {
                    normalDrums.triggerAttackRelease("32n", time);
                }
            }, "8n");
            
            // è¿½åŠ ã®ãƒªã‚ºãƒ ï¼ˆãƒ†ãƒ³ã‚·ãƒ§ãƒ³é«˜ï¼‰
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && !isBossMusic && !isStartMusic && !isVictoryMusic && !isFinalBossMusic && normalDrums) {
                    normalDrums.triggerAttackRelease("64n", time);
                }
            }, "16n", "16n");
            
            Tone.Transport.bpm.value = 180; // ã‚ˆã‚Šé€Ÿãã€ãƒ†ãƒ³ã‚·ãƒ§ãƒ³é«˜ã
            Tone.Transport.start();
        }
        
        function startBoss1Music() {
            if (!isBoss1Music) return;
            
            Tone.Transport.cancel();
            console.log("Starting 1st boss music - Flame Demon Lord");
            
            // ç‚ç„ã®é­”ç‹BGMï¼ˆé‡åšã§å¨åœ§çš„ï¼‰
            const boss1Main = ["Bb3", "C4", "D4", "F4", "G4", "Bb4", "A4", "G4"];
            const boss1LeadMelody = ["D5", "C5", "Bb4", "A4", "Bb4", "C5", "D5", "F5"];  
            const boss1BassPattern = ["Bb1", "Bb1", "F2", "F2", "G2", "G2", "D2", "D2"];
            
            let boss1MainIndex = 0;
            let boss1LeadIndex = 0;
            let boss1BassIndex = 0;
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isBoss1Music && boss1Synth) {
                    boss1Synth.triggerAttackRelease(boss1Main[boss1MainIndex % boss1Main.length], "4n", time);
                    boss1MainIndex++;
                }
            }, "4n");
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isBoss1Music && boss1Lead) {
                    boss1Lead.triggerAttackRelease(boss1LeadMelody[boss1LeadIndex % boss1LeadMelody.length], "2n", time);
                    boss1LeadIndex++;
                }
            }, "2n");
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isBoss1Music && boss1Bass) {
                    boss1Bass.triggerAttackRelease(boss1BassPattern[boss1BassIndex % boss1BassPattern.length], "1n", time);
                    boss1BassIndex++;
                }
            }, "1n");
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isBoss1Music && boss1Drums) {
                    boss1Drums.triggerAttackRelease("8n", time);
                }
            }, "2n");
            
            Tone.Transport.bpm.value = 160; // é‡åšãªãƒ†ãƒ³ãƒ
            Tone.Transport.start();
        }
        
        function startBoss2Music() {
            if (!isBoss2Music) return;
            
            Tone.Transport.cancel();
            console.log("Starting 2nd boss music - Ice Demon Lord");
            
            // æ°·çµã®é­”ç‹BGMï¼ˆå†·å¾¹ã§ç¥ç§˜çš„ï¼‰
            const boss2Main = ["C4", "D4", "Eb4", "F4", "G4", "Ab4", "Bb4", "C5"];
            const boss2LeadMelody = ["Eb5", "D5", "C5", "Bb4", "Ab4", "G4", "F4", "Eb4"];  
            const boss2BassPattern = ["C2", "C2", "Ab2", "Ab2", "Bb2", "Bb2", "C2", "C2"];
            
            let boss2MainIndex = 0;
            let boss2LeadIndex = 0;
            let boss2BassIndex = 0;
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isBoss2Music && boss2Synth) {
                    boss2Synth.triggerAttackRelease(boss2Main[boss2MainIndex % boss2Main.length], "4n", time);
                    boss2MainIndex++;
                }
            }, "4n");
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isBoss2Music && boss2Lead) {
                    boss2Lead.triggerAttackRelease(boss2LeadMelody[boss2LeadIndex % boss2LeadMelody.length], "2n", time);
                    boss2LeadIndex++;
                }
            }, "2n");
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isBoss2Music && boss2Bass) {
                    boss2Bass.triggerAttackRelease(boss2BassPattern[boss2BassIndex % boss2BassPattern.length], "1n", time);
                    boss2BassIndex++;
                }
            }, "1n");
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isBoss2Music && boss2Drums) {
                    boss2Drums.triggerAttackRelease("8n", time);
                }
            }, "4n");
            
            Tone.Transport.bpm.value = 180; // ã‚„ã‚„é€Ÿã‚ã®ãƒ†ãƒ³ãƒ
            Tone.Transport.start();
        }
        
        function startBoss3Music() {
            if (!isBoss3Music) return;
            
            Tone.Transport.cancel();
            console.log("Starting 3rd boss music - Ultimate Medusa");
            
            // ãƒ¡ãƒ‡ãƒ¥ãƒ¼ã‚µBGMï¼ˆçµ¶æœ›çš„ã§åœ§å€’çš„ï¼‰
            const boss3Main = ["C#3", "D#3", "F3", "G#3", "A#3", "C#4", "D#4", "F4"];
            const boss3LeadMelody = ["C#5", "D#5", "F5", "G#5", "A#5", "C#6", "D#6", "F6"];
            const boss3BassPattern = ["C#1", "C#1", "F#1", "F#1", "G#1", "G#1", "C#1", "C#1"];
            
            let boss3MainIndex = 0;
            let boss3LeadIndex = 0;
            let boss3BassIndex = 0;
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isBoss3Music && boss3Synth) {
                    boss3Synth.triggerAttackRelease(boss3Main[boss3MainIndex % boss3Main.length], "8n", time);
                    boss3MainIndex++;
                }
            }, "8n");
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isBoss3Music && boss3Lead) {
                    boss3Lead.triggerAttackRelease(boss3LeadMelody[boss3LeadIndex % boss3LeadMelody.length], "4n", time);
                    boss3LeadIndex++;
                }
            }, "4n");
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isBoss3Music && boss3Bass) {
                    boss3Bass.triggerAttackRelease(boss3BassPattern[boss3BassIndex % boss3BassPattern.length], "2n", time);
                    boss3BassIndex++;
                }
            }, "2n");
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isBoss3Music && boss3Drums) {
                    boss3Drums.triggerAttackRelease("16n", time);
                }
            }, "8n");
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isBoss3Music && boss3Drums) {
                    boss3Drums.triggerAttackRelease("32n", time);
                }
            }, "4n");
            
            Tone.Transport.bpm.value = 240; // æœ€é«˜é€Ÿåº¦ã€ç©¶æ¥µã®è¿«åŠ›
            Tone.Transport.start();
        }
        
        function startFinalBossMusic() {
            if (!isFinalBossMusic) return;
            
            Tone.Transport.cancel();
            console.log("Starting ultimate final boss music");
            
            // åœ§å€’çš„å¨åœ§æ„Ÿã®æœ€çµ‚ãƒœã‚¹BGM
            const finalBossMain = ["C#3", "D#3", "F3", "G#3", "A#3", "C#4", "D#4", "F4"];
            const finalBossLeadMelody = ["C#5", "D#5", "F5", "G#5", "A#5", "C#6", "D#6", "F6"];
            const finalBossBassPattern = ["C#1", "C#1", "F#1", "F#1", "G#1", "G#1", "C#1", "C#1"];
            
            let finalMainIndex = 0;
            let finalLeadIndex = 0;
            let finalBassIndex = 0;
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isFinalBossMusic && finalBossSynth) {
                    finalBossSynth.triggerAttackRelease(finalBossMain[finalMainIndex % finalBossMain.length], "4n", time);
                    finalMainIndex++;
                }
            }, "4n");
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isFinalBossMusic && finalBossLead) {
                    finalBossLead.triggerAttackRelease(finalBossLeadMelody[finalLeadIndex % finalBossLeadMelody.length], "2n", time);
                    finalLeadIndex++;
                }
            }, "2n");
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isFinalBossMusic && finalBossBass) {
                    finalBossBass.triggerAttackRelease(finalBossBassPattern[finalBassIndex % finalBossBassPattern.length], "1n", time);
                    finalBassIndex++;
                }
            }, "1n");
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isFinalBossMusic && finalBossDrums) {
                    finalBossDrums.triggerAttackRelease("8n", time);
                }
            }, "8n");
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isFinalBossMusic && finalBossDrums) {
                    finalBossDrums.triggerAttackRelease("16n", time);
                }
            }, "4n");
            
            Tone.Transport.bpm.value = 240; // æœ€é«˜é€Ÿåº¦ã€ç©¶æ¥µã®è¿«åŠ›
            Tone.Transport.start();
        }
        
        function startBossMusic() {
            if (!isBossMusic) return;
            
            Tone.Transport.cancel();
            console.log("Starting ultimate boss music");
            
            // åœ§å€’çš„è¿«åŠ›ã®ãƒœã‚¹æˆ¦BGM
            const ultimateBossMain = ["Bb3", "C4", "D4", "F4", "G4", "Bb4", "A4", "G4", "F4", "G4", "A4", "D4"];
            const ultimateBossLead = ["D5", "C5", "Bb4", "A4", "Bb4", "C5", "D5", "F5", "G5", "F5", "D5", "C5"];  
            const ultimateBossBass = ["Bb1", "Bb1", "F2", "F2", "G2", "G2", "D2", "D2"];
            
            let bossMainIndex = 0;
            let bossLeadIndex = 0;
            let bossBassIndex = 0;
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isBossMusic && bossSynth) {
                    bossSynth.triggerAttackRelease(ultimateBossMain[bossMainIndex % ultimateBossMain.length], "8n", time);
                    bossMainIndex++;
                }
            }, "8n");
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isBossMusic && bossLead) {
                    bossLead.triggerAttackRelease(ultimateBossLead[bossLeadIndex % ultimateBossLead.length], "4n", time);
                    bossLeadIndex++;
                }
            }, "4n");
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isBossMusic && bossBass) {
                    bossBass.triggerAttackRelease(ultimateBossBass[bossBassIndex % ultimateBossBass.length], "2n", time);
                    bossBassIndex++;
                }
            }, "2n");
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isBossMusic && bossDrums) {
                    bossDrums.triggerAttackRelease("16n", time);
                }
            }, "4n");
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isBossMusic && bossDrums) {
                    bossDrums.triggerAttackRelease("32n", time);
                }
            }, "8n");
            
            Tone.Transport.scheduleRepeat((time) => {
                if (musicEnabled && isBossMusic && bossDrums) {
                    bossDrums.triggerAttackRelease("64n", time);
                }
            }, "16n", "16n");
            
            Tone.Transport.bpm.value = 220; // è¶…é«˜é€Ÿã€æœ€å¤§é™ã®è¿«åŠ›
            Tone.Transport.start();
        }
        
        function switchToBossMusic() {
            try {
                isBossMusic = true;
                isFinalBossMusic = false;
                isStartMusic = false;
                isVictoryMusic = false;
                if (musicStarted) {
                    startBossMusic();
                }
            } catch (e) {
                console.warn('Error switching to boss music:', e);
            }
        }
        
        function switchToFinalBossMusic() {
            try {
                isFinalBossMusic = true;
                isBossMusic = false;
                isFinalBossMusic = false;
                isStartMusic = false;
                isVictoryMusic = false;
                if (musicStarted) {
                    startFinalBossMusic();
                }
            } catch (e) {
                console.warn('Error switching to final boss music:', e);
            }
        }
        
        function switchToNormalMusic() {
            try {
                isBossMusic = false;
                isFinalBossMusic = false;
                isStartMusic = false;
                isVictoryMusic = false;
                if (musicStarted) {
                    startEpicMusic();
                }
            } catch (e) {
                console.warn('Error switching to normal music:', e);
            }
        }
        
        function switchToStartMusic() {
            try {
                isStartMusic = true;
                isBossMusic = false;
                isFinalBossMusic = false;
                isVictoryMusic = false;
                if (musicStarted) {
                    startZeviousMusic();
                }
            } catch (e) {
                console.warn('Error switching to start music:', e);
            }
        }
        
        function switchToVictoryMusic() {
            try {
                isVictoryMusic = true;
                isBossMusic = false;
                isFinalBossMusic = false;
                isStartMusic = false;
                if (musicStarted) {
                    startVictoryMusic();
                }
            } catch (e) {
                console.warn('Error switching to victory music:', e);
            }
        }
        
        function toggleMusic() {
            try {
                if (!musicStarted) {
                    initializeMusic();
                }
                musicEnabled = !musicEnabled;
                const toggleElement = document.getElementById('musicToggle');
                if (toggleElement) {
                    toggleElement.textContent = musicEnabled ? 'ğŸµ BGM: ON' : 'ğŸ”‡ BGM: OFF';
                }
            } catch (e) {
                console.warn('Error toggling music:', e);
            }
        }
        
        // ãƒ‰ãƒƒãƒˆçµµæç”»é–¢æ•°
        function drawSprite(spriteKey, x, y, scale = 2) {
            try {
                const sprite = spriteData[spriteKey];
                if (!sprite || !Array.isArray(sprite)) return;
                
                for (let row = 0; row < sprite.length; row++) {
                    if (!sprite[row] || !Array.isArray(sprite[row])) continue;
                    for (let col = 0; col < sprite[row].length; col++) {
                        const colorIndex = sprite[row][col];
                        if (colorIndex !== 0 && colors[colorIndex]) { // é€æ˜è‰²ä»¥å¤–ã‹ã¤è‰²ãŒå­˜åœ¨
                            ctx.fillStyle = colors[colorIndex];
                            ctx.fillRect(
                                x + col * scale, 
                                y + row * scale, 
                                scale, 
                                scale
                            );
                        }
                    }
                }
            } catch (e) {
                console.warn('Error drawing sprite:', spriteKey, e);
            }
        }
        
        // æŸ±æç”»é–¢æ•°ï¼ˆå·¦å³ç«¯ã«é…ç½®ï¼‰
        function drawPillars() {
            // å·¦ã®æŸ±
            ctx.fillStyle = '#A0A0A0';
            ctx.fillRect(0, 0, 40, canvas.height);
            ctx.fillStyle = '#778899';
            ctx.fillRect(8, 0, 24, canvas.height);
            
            // æŸ±ã®è£…é£¾
            for (let y = 20; y < canvas.height; y += 60) {
                ctx.fillStyle = '#696969';
                ctx.fillRect(4, y, 32, 20);
            }
            
            // å³ã®æŸ±
            ctx.fillStyle = '#A0A0A0';
            ctx.fillRect(canvas.width - 40, 0, 40, canvas.height);
            ctx.fillStyle = '#778899';
            ctx.fillRect(canvas.width - 32, 0, 24, canvas.height);
            
            // å³æŸ±ã®è£…é£¾
            for (let y = 20; y < canvas.height; y += 60) {
                ctx.fillStyle = '#696969';
                ctx.fillRect(canvas.width - 36, y, 32, 20);
            }
        }
        
        // å·ã®æç”»é–¢æ•°ï¼ˆç¸¦ã«æµã‚Œã‚‹å·ï¼‰
        function drawRiver(x, y, width, height) {
            // é’ã„æ°´
            ctx.fillStyle = '#4169E1';
            ctx.fillRect(x, y, width, height);
            
            // ç¸¦ã®æ°´ã®æµã‚Œã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            ctx.fillStyle = '#87CEEB';
            for (let i = 0; i < height; i += 30) {
                let waveOffset = Math.sin((Date.now() * 0.005) + (i * 0.1)) * 8;
                ctx.fillRect(x + 20 + waveOffset, y + i, 15, 20);
                ctx.fillRect(x + 50 + waveOffset, y + i + 10, 12, 15);
                ctx.fillRect(x + 80 + waveOffset, y + i + 5, 10, 18);
            }
        }
        
        // æ©‹ã®æç”»é–¢æ•°ï¼ˆç¸¦ã«å·ã‚’æ¨ªåˆ‡ã‚‹æ©‹ï¼‰
        function drawBridge(x, y, width, height) {
            // å·ã®ä¸Šã«æ©‹ã‚’æç”»ï¼ˆç¸¦ã«2æœ¬ã®æ©‹è„šï¼‰
            
            // 1æœ¬ç›®ã®æ©‹ï¼ˆå·¦å¯„ã‚Šï¼‰
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x + 20, y, 25, height);
            
            // 2æœ¬ç›®ã®æ©‹ï¼ˆå³å¯„ã‚Šï¼‰
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x + 55, y, 25, height);
            
            // æ©‹ã®æ‰‹ã™ã‚Šï¼ˆç¸¦æ–¹å‘ï¼‰
            ctx.fillStyle = '#654321';
            ctx.fillRect(x + 20, y, 4, height);
            ctx.fillRect(x + 41, y, 4, height);
            ctx.fillRect(x + 55, y, 4, height);
            ctx.fillRect(x + 76, y, 4, height);
            
            // æ©‹ã®æ¿ã®æ¨¡æ§˜ï¼ˆæ¨ªæ¿ï¼‰
            ctx.fillStyle = '#A0522D';
            for (let i = 0; i < height; i += 15) {
                ctx.fillRect(x + 22, y + i, 21, 10);
                ctx.fillRect(x + 57, y + i, 21, 10);
            }
            
            // æ©‹è„šã®æ”¯æŸ±ï¼ˆæ¨ªæ–¹å‘ã®æ”¯ãˆï¼‰
            ctx.fillStyle = '#654321';
            for (let i = 20; i < height; i += 30) {
                ctx.fillRect(x + 18, y + i, 29, 4);
                ctx.fillRect(x + 53, y + i, 29, 4);
            }
        }
        
        const stages = [
            { name: "è‰åŸ", skyTop: "#87CEEB", skyBottom: "#228B22" },
            { name: "å¤•ç„¼ã‘", skyTop: "#FF6347", skyBottom: "#FFD700" },
            { name: "å¤œ", skyTop: "#191970", skyBottom: "#000080" },
            { name: "åœ°ä¸‹", skyTop: "#2F2F2F", skyBottom: "#000000" },
            { name: "é­”ç•Œ", skyTop: "#8B0000", skyBottom: "#4B0000" }
        ];
        
        let gameState = {
            score: 0,
            hp: 60, // ä½“åŠ›ã‚’100â†’60ã«å‰Šæ¸›ã—ã¦ç·Šå¼µæ„Ÿã‚¢ãƒƒãƒ—
            level: 1,
            gameOver: false,
            gameStarted: false, // ã‚²ãƒ¼ãƒ é–‹å§‹ãƒ•ãƒ©ã‚°è¿½åŠ 
            scrollSpeed: 0.2, // ã•ã‚‰ã«é…ãï¼šæ­©è¡Œæ„Ÿã‚’é‡è¦–
            enemySpawnRate: 0.008, // æ•µå‡ºç¾ç‡ã‚’å‰Šæ¸›ï¼ˆ0.015â†’0.008ï¼‰
            powerUpSpawnRate: 0.005,
            backgroundOffset: 0,
            weaponLevel: 1,
            bossActive: false,
            totalDistance: 0, // ç§»å‹•è·é›¢ã‚’è¿½è·¡
            nextBossDistance: 5000, // 1ä½“ç›®ãƒœã‚¹ã‚’ã•ã‚‰ã«é…ã‚‰ã›ã‚‹ï¼ˆ3000â†’5000ï¼‰
            laserAmmo: 10, // åˆæœŸãƒ¬ãƒ¼ã‚¶ãƒ¼å¼¾æ•°ã‚’å¢—åŠ 
            currentStage: 0,
            bossesDefeated: 0,
            gameCleared: false,
            showEnding: false,
            continuesUsed: 0, // ã‚³ãƒ³ãƒ†ã‚£ãƒ‹ãƒ¥ãƒ¼ä½¿ç”¨å›æ•°
            showContinue: false, // ã‚³ãƒ³ãƒ†ã‚£ãƒ‹ãƒ¥ãƒ¼ç”»é¢è¡¨ç¤ºãƒ•ãƒ©ã‚°
            speedModeTimer: 0, // é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒãƒ¼
            isSpeedMode: false, // é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰ãƒ•ãƒ©ã‚°
            lastRowWasRiver: false // å‰ã®è¡ŒãŒå·ã ã£ãŸã‹ã®ãƒ•ãƒ©ã‚°
        };
        
        // ãƒãƒãƒ­ãƒ³ï¼ˆ0.5625å€ã‚µã‚¤ã‚º = 36x36ã€ã•ã‚‰ã«å°ã•ãï¼‰
        let player = {
            x: canvas.width / 2,
            y: canvas.height - 100,
            width: 36,  // 0.5625å€ã‚µã‚¤ã‚ºï¼ˆ48ã®0.75å€ï¼‰
            height: 36, // 0.5625å€ã‚µã‚¤ã‚º
            speed: 4, // ç§»å‹•é€Ÿåº¦ã‚’5ã‹ã‚‰4ã«æ¸›é€Ÿ
            shootCooldown: 0,
            walkFrame: 0,
            footLOffset: 0,
            footROffset: 0,
            footLForward: 0,
            footRForward: 0,
            bodyBounce: 0,
            armLOffset: 0,
            armROffset: 0,
            headBob: 0,
            facingDirection: 1, // 1: å³å‘ã, -1: å·¦å‘ã
            lastDirection: 0 // æœ€å¾Œã®ç§»å‹•æ–¹å‘
        };
        
        let bullets = [];
        let enemies = [];
        let powerUps = [];
        let particles = [];
        let backgroundTiles = [];
        let questionBoxes = [];
        let bosses = [];
        let enemyBullets = [];
        
        const weaponNames = {
            1: "é€šå¸¸å¼¾", 2: "2é€£å¼¾", 3: "3WAYå¼¾", 4: "5WAYå¼¾",
            5: "ã‚µãƒ¼ã‚¯ãƒ«å¼¾", 6: "ä¸€æ’ƒå¿…æ®ºãƒ¬ãƒ¼ã‚¶ãƒ¼", 7: "ç‚å¼¾", 8: "é›·æ’ƒå¼¾", 9: "ãƒ•ã‚¡ã‚¤ãƒ¤ãƒ¼ãƒœãƒ¼ãƒ«"
        };
        
        function initializeBackground() {
            backgroundTiles = [];
            let lastRowWasRiver = false;
            
            for (let y = -100; y < canvas.height + 200; y += 100) {
                let row = [];
                // å·ã®å‡ºç¾ç‡ã‚’è·é›¢ã«å¿œã˜ã¦èª¿æ•´ï¼ˆåºç›¤ã¯å°‘ãªãã€ä¸­çµ‚ç›¤ã¯å¤šãï¼‰
                let riverChance = Math.min(0.15, gameState.totalDistance / 100000); // æœ€å¤§15%ã¾ã§å¢—åŠ 
                if (gameState.totalDistance < 3000) riverChance = 0.02; // åºç›¤ã¯2%ã®ã¿
                else if (gameState.totalDistance < 8000) riverChance = 0.05; // ä¸­ç›¤å‰ã¯5%
                else if (gameState.totalDistance < 15000) riverChance = 0.08; // ä¸­ç›¤ã¯8%
                
                // å‰ã®è¡ŒãŒå·ã ã£ãŸå ´åˆã¯å·ã‚’å‡ºç¾ã•ã›ãªã„
                let isRiverRow = !lastRowWasRiver && Math.random() < riverChance;
                let bridgePositions = [];
                
                if (isRiverRow) {
                    // å·ã®è¡Œã®å ´åˆã€1-3ç®‡æ‰€ã«æ©‹ã‚’é…ç½®
                    let bridgeCount = Math.random() < 0.4 ? 1 : (Math.random() < 0.7 ? 2 : 3);
                    for (let i = 0; i < bridgeCount; i++) {
                        let bridgeIndex = Math.floor(Math.random() * Math.floor((canvas.width - 100) / 100));
                        bridgePositions.push(bridgeIndex);
                    }
                }
                
                let tileIndex = 0;
                for (let x = 50; x < canvas.width - 50; x += 100) { // æŸ±ã‚’é¿ã‘ã¦ç”Ÿæˆ
                    let tileType = 'grass';
                    
                    if (isRiverRow) {
                        if (bridgePositions.includes(tileIndex)) {
                            tileType = 'bridge';
                        } else {
                            tileType = 'river';
                        }
                    }
                    
                    row.push({ type: tileType, x: x, variation: Math.floor(Math.random() * 3) });
                    tileIndex++;
                }
                backgroundTiles.push({ y: y, tiles: row });
                lastRowWasRiver = isRiverRow; // æ¬¡ã®è¡Œã®ãŸã‚ã«è¨˜éŒ²
            }
            gameState.lastRowWasRiver = lastRowWasRiver;
        }
        
        initializeBackground();
        
        function changeStage() {
            gameState.currentStage = (gameState.currentStage + 1) % stages.length;
            document.getElementById('stageText').textContent = `STAGE ${gameState.currentStage + 1}: ${stages[gameState.currentStage].name}`;
            document.getElementById('stageInfo').style.display = 'block';
            setTimeout(() => {
                document.getElementById('stageInfo').style.display = 'none';
            }, 3000);
        }
        
        let keys = {};
        let continueTimer = 0; // ã‚³ãƒ³ãƒ†ã‚£ãƒ‹ãƒ¥ãƒ¼ã‚¿ã‚¤ãƒãƒ¼
        
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            // ã‚²ãƒ¼ãƒ é–‹å§‹å‡¦ç†
            if (e.code === 'Space' && !gameState.gameStarted) {
                startGame();
                return;
            }
            
            if (e.code === 'KeyR' && (gameState.gameOver || gameState.showEnding || gameState.showContinue)) {
                restartGame();
            }
            if (e.code === 'KeyC' && gameState.showContinue && gameState.continuesUsed < 5) {
                continueGame();
            }
        });
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        function startGame() {
            try {
                gameState.gameStarted = true;
                document.getElementById('startScreen').style.display = 'none';
                
                // ã‚¹ã‚¿ãƒ¼ãƒˆBGMé–‹å§‹
                if (!musicStarted) {
                    initializeMusic().then(() => {
                        switchToStartMusic();
                    });
                } else {
                    switchToStartMusic();
                }
            } catch (e) {
                console.error('Error starting game:', e);
            }
        }
        
        // ãƒãƒãƒ­ãƒ³æ›´æ–°ï¼ˆæ”¹è‰¯ã•ã‚ŒãŸæ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰å¯¾å¿œï¼‰
        function updatePlayer() {
            try {
                if (!gameState.gameStarted) return;
                
                // ã‚¹ã‚¿ãƒ¼ãƒˆBGMã‚¿ã‚¤ãƒãƒ¼å‡¦ç†
                if (isStartMusic && startMusicTimer > 0) {
                    startMusicTimer--;
                    if (startMusicTimer <= 0) {
                        switchToNormalMusic();
                    }
                }
                
                // é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
                if (gameState.speedModeTimer > 0) {
                    gameState.speedModeTimer--;
                    gameState.isSpeedMode = true;
                } else {
                    gameState.isSpeedMode = false;
                }
                
                let isMoving = false;
                let horizontalMovement = 0;
                let currentSpeed = gameState.isSpeedMode ? player.speed * 2.5 : player.speed; // é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰æ™‚ã¯2.5å€
                let newX = player.x;
                let newY = player.y;
                
                if (keys['ArrowLeft'] && player.x > 50) { // æŸ±ã‚’é¿ã‘ã‚‹
                    newX = player.x - currentSpeed;
                    isMoving = true;
                    horizontalMovement = -1;
                    player.facingDirection = -1; // å·¦å‘ã
                    player.lastDirection = -1;
                }
                if (keys['ArrowRight'] && player.x < canvas.width - 50 - player.width) { // æŸ±ã‚’é¿ã‘ã‚‹
                    newX = player.x + currentSpeed;
                    isMoving = true;
                    horizontalMovement = 1;
                    player.facingDirection = 1; // å³å‘ã
                    player.lastDirection = 1;
                }
                if (keys['ArrowUp'] && player.y > 0) {
                    newY = player.y - currentSpeed;
                    isMoving = true;
                }
                if (keys['ArrowDown'] && player.y < canvas.height - player.height) {
                    newY = player.y + currentSpeed;
                    isMoving = true;
                }
                
                // æ–°ã—ã„ä½ç½®ãŒå·ã§ãªã„ã‹ãƒã‚§ãƒƒã‚¯
                if (!checkPlayerInRiverAtPosition(newX, newY)) {
                    player.x = newX;
                    player.y = newY;
                } else {
                    // å·ã«å…¥ã‚‹å ´åˆã¯ç§»å‹•ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                    isMoving = false;
                }
                
                // å‘ãã®è‡ªç„¶ãªå¤‰åŒ–ï¼ˆæ€¥æ¿€ã«å¤‰ã‚ã‚‰ãªã„ã‚ˆã†ã«ï¼‰
                if (player.lastDirection === 0) {
                    // å¾ã€…ã«æ­£é¢ã‚’å‘ã
                    if (player.facingDirection > 0.1) {
                        player.facingDirection -= 0.05;
                    } else if (player.facingDirection < -0.1) {
                        player.facingDirection += 0.05;
                    } else {
                        player.facingDirection = 0;
                    }
                }
                
                // å®‰å…¨ãªå€¤ã®åˆæœŸåŒ–
                player.walkFrame = player.walkFrame || 0;
                player.bodyBounce = player.bodyBounce || 0;
                player.headBob = player.headBob || 0;
                player.armLOffset = player.armLOffset || 0;
                player.armROffset = player.armROffset || 0;
                player.footLOffset = player.footLOffset || 0;
                player.footROffset = player.footROffset || 0;
                player.footLForward = player.footLForward || 0;
                player.footRForward = player.footRForward || 0;
                
                // æ”¹è‰¯ã•ã‚ŒãŸæ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆé«˜é€Ÿãƒ¢ãƒ¼ãƒ‰æ™‚ã¯é€Ÿãã€ã‚ˆã‚Šã‚¹ãƒ ãƒ¼ã‚ºã«ï¼‰
                let walkSpeed = gameState.isSpeedMode ? 1.2 : 0.6;
                if (isMoving) {
                    player.walkFrame += walkSpeed; // ã‚¹ãƒ ãƒ¼ã‚ºãªæ­©è¡Œãƒªã‚ºãƒ 
                    
                    // ã‚ˆã‚Šã‚¹ãƒ ãƒ¼ã‚ºãªè¶³ã®å‹•ãï¼ˆã‚µã‚¤ãƒ³æ³¢ã‚’ã‚ˆã‚Šãªã‚ã‚‰ã‹ã«ï¼‰
                    player.footLOffset = Math.sin(player.walkFrame) * 8;
                    player.footLForward = Math.cos(player.walkFrame + 0.1) * 6;
                    player.footROffset = Math.sin(player.walkFrame + Math.PI) * 8;
                    player.footRForward = Math.cos(player.walkFrame + Math.PI + 0.1) * 6;
                    
                    // ä½“ã®ä¸Šä¸‹å‹•ï¼ˆæ­©è¡Œã«åˆã‚ã›ã¦ã€ã‚ˆã‚Šãªã‚ã‚‰ã‹ï¼‰
                    player.bodyBounce = Math.sin(player.walkFrame * 2) * (gameState.isSpeedMode ? 4 : 2);
                    
                    // é ­ã®å¾®å¦™ãªå·¦å³ã®å‹•ãï¼ˆæ­©è¡Œãƒªã‚ºãƒ ã«åˆã‚ã›ã¦ï¼‰
                    player.headBob = Math.sin(player.walkFrame * 1.2) * 1.5;
                    
                    // è…•ã®æŒ¯ã‚Šï¼ˆè¶³ã¨é€†ä½ç›¸ã§è‡ªç„¶ã«ã€ã‚ˆã‚Šã‚¹ãƒ ãƒ¼ã‚ºï¼‰
                    player.armLOffset = Math.sin(player.walkFrame + Math.PI) * (gameState.isSpeedMode ? 6 : 4);
                    player.armROffset = Math.sin(player.walkFrame) * (gameState.isSpeedMode ? 6 : 4);
                } else {
                    // é™æ­¢æ™‚ã¯å¾®å¦™ãªå‹•ãï¼ˆã‚ˆã‚Šãªã‚ã‚‰ã‹ï¼‰
                    player.walkFrame += 0.15;
                    
                    // å¾®å¦™ãªè¶³è¸ã¿ï¼ˆã‚ˆã‚Šè‡ªç„¶ã«ï¼‰
                    player.footLOffset = Math.sin(player.walkFrame * 0.4) * 2;
                    player.footLForward = Math.cos(player.walkFrame * 0.4) * 1.5;
                    player.footROffset = Math.sin(player.walkFrame * 0.4 + Math.PI) * 2;
                    player.footRForward = Math.cos(player.walkFrame * 0.4 + Math.PI) * 1.5;
                    
                    // é™æ­¢æ™‚ã®å¾®å¦™ãªä½“ã®å‹•ã
                    player.bodyBounce = Math.sin(player.walkFrame * 0.25) * 0.8;
                    
                    // é™æ­¢æ™‚ã®é ­ã®å¾®å¦™ãªå‹•ã
                    player.headBob = Math.sin(player.walkFrame * 0.15) * 0.3;
                    
                    // è…•ã®å¾®å¦™ãªå‹•ã
                    player.armLOffset = Math.sin(player.walkFrame * 0.3) * 1.5;
                    player.armROffset = Math.sin(player.walkFrame * 0.3 + 0.8) * 1.5;
                }
                
                // ç§»å‹•æ–¹å‘ã‚’ãƒªã‚»ãƒƒãƒˆ
                if (!keys['ArrowLeft'] && !keys['ArrowRight']) {
                    player.lastDirection = 0;
                }
                
                if (keys['Space'] && player.shootCooldown <= 0) {
                    shootBullets();
                    if (musicEnabled && shootSE) {
                        try {
                            shootSE.triggerAttackRelease("G#5", "32n");
                        } catch (e) {
                            console.warn('Error playing shoot sound:', e);
                        }
                    }
                    player.shootCooldown = gameState.weaponLevel >= 6 ? 20 : (gameState.weaponLevel >= 3 ? 12 : 8);
                }
                
                // å·ï¼ˆæ± ï¼‰ã«ãƒãƒã£ãŸæ™‚ã®å³æ­»ã‚·ã‚¹ãƒ†ãƒ 
                if (checkPlayerInRiverAtPosition(player.x, player.y)) {
                    gameState.hp = 0; // å³æ­»
                    if (gameState.continuesUsed < 5) {
                        gameState.showContinue = true;
                        continueTimer = 600; // 10ç§’ (60fps * 10)
                    } else {
                        gameState.gameOver = true;
                    }
                }
                
                if (keys['Space'] && player.shootCooldown <= 0) {
                    shootBullets();
                    if (musicEnabled && shootSE) {
                        try {
                            shootSE.triggerAttackRelease("G#5", "32n");
                        } catch (e) {
                            console.warn('Error playing shoot sound:', e);
                        }
                    }
                    player.shootCooldown = gameState.weaponLevel >= 6 ? 20 : (gameState.weaponLevel >= 3 ? 12 : 8);
                }
                
                if (player.shootCooldown > 0) {
                    player.shootCooldown--;
                }
            } catch (e) {
                console.error('Error updating player:', e);
                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šåŸºæœ¬çš„ãªç§»å‹•ã®ã¿
                if (keys['ArrowLeft'] && player.x > 50) {
                    player.x -= player.speed;
                }
                if (keys['ArrowRight'] && player.x < canvas.width - 50 - player.width) {
                    player.x += player.speed;
                }
                if (keys['ArrowUp'] && player.y > 0) {
                    player.y -= player.speed;
                }
                if (keys['ArrowDown'] && player.y < canvas.height - player.height) {
                    player.y += player.speed;
                }
            }
        }
        
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæŒ‡å®šä½ç½®ã§å·ã®ä¸­ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆæ©‹ä»¥å¤–ï¼‰
        function checkPlayerInRiverAtPosition(x, y) {
            for (let row of backgroundTiles) {
                if (row.y <= y + player.height && row.y + 100 >= y) {
                    for (let tile of row.tiles) {
                        if (tile.x <= x + player.width && tile.x + 100 >= x) {
                            if (tile.type === 'river') {
                                return true; // å·ã«å…¥ã£ã¦ã„ã‚‹
                            }
                            if (tile.type === 'bridge') {
                                // æ©‹ã®ä¸Šã‹ãƒã‚§ãƒƒã‚¯ï¼ˆç¸¦æ©‹å¯¾å¿œãƒ»ã‚ˆã‚ŠæŸ”è»Ÿã«ï¼‰
                                let bridgeX1 = tile.x + 18; // 1æœ¬ç›®ã®æ©‹ï¼ˆå°‘ã—ä½™è£•ã‚’æŒãŸã›ã‚‹ï¼‰
                                let bridgeX2 = tile.x + 53; // 2æœ¬ç›®ã®æ©‹ï¼ˆå°‘ã—ä½™è£•ã‚’æŒãŸã›ã‚‹ï¼‰
                                let bridgeWidth1 = 29; // 1æœ¬ç›®ã®æ©‹å¹…ï¼ˆå°‘ã—åºƒãï¼‰
                                let bridgeWidth2 = 29; // 2æœ¬ç›®ã®æ©‹å¹…ï¼ˆå°‘ã—åºƒãï¼‰
                                
                                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã©ã¡ã‚‰ã‹ã®æ©‹ã®ä¸Šã«ã„ã‚‹ã‹ï¼ˆé‡ãªã‚Šåˆ¤å®šã‚’ç·©ãï¼‰
                                let onBridge1 = (x + player.width > bridgeX1 && x < bridgeX1 + bridgeWidth1);
                                let onBridge2 = (x + player.width > bridgeX2 && x < bridgeX2 + bridgeWidth2);
                                
                                if (!onBridge1 && !onBridge2) {
                                    return true; // æ©‹ä»¥å¤–ã®å·éƒ¨åˆ†
                                }
                            }
                        }
                    }
                }
            }
            return false; // å·ã§ã¯ãªã„
        }
        
        function shootBullets() {
            let centerX = player.x + player.width / 2;
            let centerY = player.y;
            
            switch (gameState.weaponLevel) {
                case 1:
                    bullets.push({
                        x: centerX, y: centerY, width: 8, height: 16, speed: 12, damage: 25,
                        color: '#ffffff', type: 'sword', angle: -Math.PI/2
                    });
                    break;
                case 2:
                    bullets.push({ x: centerX - 12, y: centerY, width: 8, height: 16, speed: 12, damage: 25, color: '#ffffff', type: 'sword', angle: -Math.PI/2 });
                    bullets.push({ x: centerX + 12, y: centerY, width: 8, height: 16, speed: 12, damage: 25, color: '#ffffff', type: 'sword', angle: -Math.PI/2 });
                    break;
                case 3:
                    for (let i = -1; i <= 1; i++) {
                        bullets.push({ x: centerX, y: centerY, width: 8, height: 16, speed: 12, damage: 25, color: '#ffffff', type: 'sword', angle: -Math.PI/2 + i * 0.3 });
                    }
                    break;
                case 4:
                    for (let i = -2; i <= 2; i++) {
                        bullets.push({ x: centerX, y: centerY, width: 8, height: 16, speed: 12, damage: 30, color: '#ffff00', type: 'sword', angle: -Math.PI/2 + i * 0.2 });
                    }
                    break;
                case 5:
                    for (let i = 0; i < 8; i++) {
                        bullets.push({ x: centerX, y: centerY, width: 8, height: 16, speed: 12, damage: 35, color: '#ff8800', type: 'sword', angle: (i * Math.PI * 2) / 8 - Math.PI/2 });
                    }
                    break;
                case 6:
                    bullets.push({
                        x: centerX, y: centerY, width: 120, height: player.y, speed: 0, damage: 9999,
                        color: '#00ffff', type: 'mega_laser', life: 45, angle: -Math.PI/2, intensity: 1.0
                    });
                    break;
                case 7:
                    for (let i = -4; i <= 4; i++) {
                        bullets.push({ x: centerX, y: centerY, width: 12, height: 12, speed: 8 + Math.random() * 4, damage: 40, color: '#ff4400', type: 'flame', angle: -Math.PI/2 + i * 0.12, life: 35 });
                    }
                    break;
                case 8:
                    for (let i = 0; i < 5; i++) {
                        bullets.push({ x: centerX + (i - 2) * 18, y: centerY, width: 12, height: 24, speed: 15, damage: 60, color: '#ffff00', type: 'thunder', angle: -Math.PI/2, zigzag: 0 });
                    }
                    break;
                case 9:
                    for (let i = 0; i < 3; i++) {
                        bullets.push({ 
                            x: centerX + (i - 1) * 25, y: centerY, width: 24, height: 24, speed: 10, damage: 100, 
                            color: '#FF4500', type: 'fireball', angle: -Math.PI/2, 
                            fireEffect: 0, life: 60, trail: []
                        });
                    }
                    break;
            }
        }
        
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                let bullet = bullets[i];
                
                if (bullet.type === 'mega_laser') {
                    bullet.life--;
                    bullet.intensity = bullet.life / 45.0;
                    if (bullet.life <= 0) {
                        bullets.splice(i, 1);
                    }
                } else if (bullet.type === 'flame') {
                    bullet.x += Math.cos(bullet.angle) * bullet.speed;
                    bullet.y += Math.sin(bullet.angle) * bullet.speed;
                    bullet.life--;
                    if (bullet.life <= 0) {
                        bullets.splice(i, 1);
                    }
                } else if (bullet.type === 'thunder') {
                    bullet.x += Math.cos(bullet.angle) * bullet.speed;
                    bullet.y += Math.sin(bullet.angle) * bullet.speed;
                    bullet.zigzag += 0.3;
                    bullet.x += Math.sin(bullet.zigzag) * 12;
                } else if (bullet.type === 'fireball') {
                    bullet.x += Math.cos(bullet.angle) * bullet.speed;
                    bullet.y += Math.sin(bullet.angle) * bullet.speed;
                    bullet.fireEffect += 0.2;
                    bullet.life--;
                    
                    // è»Œè·¡ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¿½åŠ 
                    bullet.trail = bullet.trail || [];
                    bullet.trail.push({ x: bullet.x, y: bullet.y, life: 15 });
                    
                    // å¤ã„è»Œè·¡ã‚’å‰Šé™¤
                    bullet.trail = bullet.trail.filter(t => {
                        t.life--;
                        return t.life > 0;
                    });
                    
                    // ç‚ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç”Ÿæˆ
                    if (Math.random() < 0.3) {
                        createFireballParticle(bullet.x, bullet.y);
                    }
                    
                    if (bullet.life <= 0) {
                        bullets.splice(i, 1);
                        continue;
                    }
                } else {
                    bullet.x += Math.cos(bullet.angle) * bullet.speed;
                    bullet.y += Math.sin(bullet.angle) * bullet.speed;
                }
                
                if (bullet.y < -20 || bullet.y > canvas.height + 20 || bullet.x < -20 || bullet.x > canvas.width + 20) {
                    bullets.splice(i, 1);
                }
            }
        }
        
        function updateEnemyBullets() {
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                let bullet = enemyBullets[i];
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                
                if (bullet.y > canvas.height || bullet.x < 0 || bullet.x > canvas.width) {
                    enemyBullets.splice(i, 1);
                    continue;
                }
                
                if (checkCollision(player, bullet)) {
                    gameState.hp -= bullet.damage || 8; // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’10â†’8ã«å‰Šæ¸›
                    gameState.weaponLevel = 1;
                    
                    // é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰ã‚’è§£é™¤
                    gameState.speedModeTimer = 0;
                    gameState.isSpeedMode = false;
                    
                    // å¼·åŒ–ã•ã‚ŒãŸãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¨SEï¼ˆç¬é–“çš„ã ãŒè¿«åŠ›æº€ç‚¹ï¼‰
                    createPlayerDamageEffect(player.x + player.width/2, player.y + player.height/2);
                    if (musicEnabled && playerDamageSE && playerDamageSE2) {
                        try {
                            // ãƒ¡ã‚¤ãƒ³ã®ç—›ã¿SEï¼ˆé«˜éŸ³ã‹ã‚‰ä¸­éŸ³ã€ãã—ã¦ä½éŸ³ã¸ã®ã‚³ãƒ³ãƒœï¼‰
                            playerDamageSE.triggerAttackRelease("A4", "32n");
                            setTimeout(() => playerDamageSE.triggerAttackRelease("F4", "32n"), 30);
                            setTimeout(() => playerDamageSE.triggerAttackRelease("C3", "16n"), 60);
                            
                            // è¿½åŠ ã®ãƒã‚¤ã‚ºSEï¼ˆç—›ã¿ã‚’å¼·èª¿ï¼‰
                            playerDamageSE2.triggerAttackRelease("16n");
                            
                            // ç¬¬3ã®ç—›ã¿SEï¼ˆé‡ã­ã¦ã•ã‚‰ã«å¼·èª¿ï¼‰
                            setTimeout(() => {
                                if (playerDamageSE3) playerDamageSE3.triggerAttackRelease("E3", "32n");
                            }, 20);
                        } catch (e) {
                            console.warn('Error playing damage sound:', e);
                        }
                    }
                    
                    enemyBullets.splice(i, 1);
                    
                    if (gameState.hp <= 0) {
                        if (gameState.continuesUsed < 5) {
                            gameState.showContinue = true;
                            continueTimer = 600; // 10ç§’ (60fps * 10)
                        } else {
                            gameState.gameOver = true;
                        }
                    }
                }
            }
        }
        
        function spawnQuestionBox() {
            if (Math.random() < 0.004) { // é©åº¦ãªå‡ºç¾é »åº¦
                // å·ã®ä¸Šã‚’é¿ã‘ã¦é…ç½®
                let attempts = 0;
                let spawnX, spawnY;
                let validPosition = false;
                
                while (!validPosition && attempts < 10) {
                    spawnX = Math.random() * (canvas.width - 120) + 60; // æŸ±ã‚’é¿ã‘ã¦ç”Ÿæˆ
                    spawnY = -36; // ç”»é¢ä¸Šéƒ¨ã‹ã‚‰å‡ºç¾
                    
                    // ã“ã®ä½ç½®ãŒå·ã‚¿ã‚¤ãƒ«ã§ãªã„ã‹ãƒã‚§ãƒƒã‚¯
                    validPosition = true;
                    for (let row of backgroundTiles) {
                        if (row.y <= spawnY + 36 && row.y + 100 >= spawnY) {
                            for (let tile of row.tiles) {
                                if ((tile.type === 'river' || tile.type === 'bridge') && 
                                    tile.x <= spawnX + 36 && 
                                    tile.x + 100 >= spawnX) {
                                    validPosition = false;
                                    break;
                                }
                            }
                            if (!validPosition) break;
                        }
                    }
                    attempts++;
                }
                
                if (validPosition) {
                    questionBoxes.push({
                        x: spawnX,
                        y: spawnY,
                        width: 36,  // 0.75å€ã‚µã‚¤ã‚º
                        height: 36, // 0.75å€ã‚µã‚¤ã‚º
                        speed: gameState.scrollSpeed, // èƒŒæ™¯ã¨åŒã˜é€Ÿåº¦ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                        hp: 5,
                        maxHp: 5
                    });
                }
            }
        }
        
        function updateQuestionBoxes() {
            for (let i = questionBoxes.length - 1; i >= 0; i--) {
                let box = questionBoxes[i];
                
                // èƒŒæ™¯ã¨åŒã˜é€Ÿåº¦ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                box.y += box.speed;
                
                // ç”»é¢å¤–ã«å‡ºãŸå ´åˆã¯å‰Šé™¤
                if (box.y > canvas.height) {
                    questionBoxes.splice(i, 1);
                    continue;
                }
                
                for (let j = bullets.length - 1; j >= 0; j--) {
                    if (checkCollision(bullets[j], box)) {
                        box.hp--;
                        if (bullets[j].type !== 'mega_laser') {
                            bullets.splice(j, 1);
                        }
                        
                        if (box.hp <= 0) {
                            // ?ãƒœãƒƒã‚¯ã‚¹ç ´å£ŠSE
                            if (musicEnabled && questionBoxSE) {
                                try {
                                    questionBoxSE.triggerAttackRelease("C5", "8n");
                                    setTimeout(() => questionBoxSE.triggerAttackRelease("E5", "16n"), 80);
                                    setTimeout(() => questionBoxSE.triggerAttackRelease("G5", "32n"), 160);
                                } catch (e) {
                                    console.warn('Error playing question box sound:', e);
                                }
                            }
                            
                            let itemType = Math.random();
                            if (itemType < 0.5) { // æ­¦å™¨ã‚¢ãƒƒãƒ—ç¢ºç‡ã‚’50%
                                powerUps.push({
                                    x: box.x, y: box.y, width: 36, height: 36, speed: 1.5,
                                    type: 'weapon', angle: 0
                                });
                            } else if (itemType < 0.75) { // ãƒ¬ãƒ¼ã‚¶ãƒ¼å¼¾ç¢ºç‡ã‚’25%
                                powerUps.push({
                                    x: box.x, y: box.y, width: 36, height: 36, speed: 1.5,
                                    type: 'laser_ammo', angle: 0
                                });
                            } else { // é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰ç¢ºç‡ã‚’25%
                                powerUps.push({
                                    x: box.x, y: box.y, width: 36, height: 36, speed: 1.5,
                                    type: 'speed_mode', angle: 0
                                });
                            }
                            createMakidenExplosion(box.x + box.width/2, box.y + box.height/2);
                            questionBoxes.splice(i, 1);
                        }
                        break;
                    }
                }
            }
        }
        
        function checkBossSpawn() {
            try {
                if (!gameState.gameStarted) return;
                
                // ãƒœã‚¹ã®å‡ºç¾è·é›¢ã‚’å¤§å¹…ã«é…ã‚‰ã›ã¦ç·Šå¼µã¨ç·©å’Œã®ãƒãƒ©ãƒ³ã‚¹ã‚’æ”¹å–„
                let bossDistances = [5000, 12000, 20000]; // ã‚ˆã‚Šé…ã„å‡ºç¾
                let currentBossIndex = gameState.bossesDefeated || 0;
                
                if (currentBossIndex < bossDistances.length && 
                    gameState.totalDistance >= bossDistances[currentBossIndex] && 
                    !gameState.bossActive) {
                    
                    spawnBoss();
                    gameState.bossActive = true;
                    
                    // æœ€çµ‚ãƒœã‚¹ã®å ´åˆã¯ç‰¹åˆ¥ãªBGM
                    if (currentBossIndex === 2) {
                        switchToFinalBossMusic();
                    } else {
                        switchToBossMusic();
                    }
                    
                    const bossWarningElement = document.getElementById('bossWarning');
                    if (bossWarningElement) {
                        bossWarningElement.style.display = 'block';
                        setTimeout(() => {
                            if (bossWarningElement) {
                                bossWarningElement.style.display = 'none';
                            }
                        }, 3000);
                    }
                }
            } catch (e) {
                console.error('Error checking boss spawn:', e);
            }
        }
        
        function spawnBoss() {
            try {
                let bossType = (gameState.bossesDefeated || 0) % 3;
                let bossData;
                
                switch (bossType) {
                    case 0:
                        bossData = {
                            x: canvas.width / 2 - 90, y: -180, width: 180, height: 180, speed: 0.8, hp: 800, maxHp: 800, // HPã‚’1500â†’800ã«å‰Šæ¸›
                            color: '#8B0000', secondaryColor: '#DC143C', accentColor: '#FF6347', glowColor: '#FF4500',
                            type: 'flame_demon_lord', name: 'ç‚ç„ã®é­”ç‹', bulletDamage: 8 // ãƒ€ãƒ¡ãƒ¼ã‚¸å‰Šæ¸›
                        };
                        break;
                    case 1:
                        bossData = {
                            x: canvas.width / 2 - 112, y: -225, width: 225, height: 225, speed: 1.0, hp: 1200, maxHp: 1200, // HPã‚’2000â†’1200ã«å‰Šæ¸›
                            color: '#191970', secondaryColor: '#4169E1', accentColor: '#87CEEB', glowColor: '#00BFFF',
                            type: 'ice_demon_lord', name: 'æ°·çµã®é­”ç‹', bulletDamage: 12 // ãƒ€ãƒ¡ãƒ¼ã‚¸å‰Šæ¸›
                        };
                        break;
                    case 2:
                        bossData = {
                            x: canvas.width / 2 - 135, y: -270, width: 270, height: 270, speed: 1.2, hp: 1500, maxHp: 1500, // HPã‚’2500â†’1500ã«å‰Šæ¸›
                            color: '#228B22', secondaryColor: '#DC143C', accentColor: '#9932CC', glowColor: '#FF00FF',
                            type: 'medusa', name: 'ãƒ¡ãƒ‡ãƒ¥ãƒ¼ã‚µ', bulletDamage: 15, spriteScale: 16.875 // ãƒ€ãƒ¡ãƒ¼ã‚¸å‰Šæ¸›
                        };
                        break;
                    default:
                        bossData = {
                            x: canvas.width / 2 - 90, y: -180, width: 180, height: 180, speed: 0.8, hp: 800, maxHp: 800,
                            color: '#8B0000', secondaryColor: '#DC143C', accentColor: '#FF6347', glowColor: '#FF4500',
                            type: 'flame_demon_lord', name: 'ç‚ç„ã®é­”ç‹', bulletDamage: 8
                        };
                        break;
                }
                
                // å®‰å…¨ãªåˆæœŸåŒ–
                bossData.pattern = 'boss_move';
                bossData.angle = 0;
                bossData.shootCooldown = 80; // æ”»æ’ƒé »åº¦ã‚’ä¸‹ã’ã‚‹
                bossData.phase = 1;
                bossData.attackPattern = 0;
                bossData.moveTimer = 0;
                bossData.walkFrame = 0;
                bossData.eyeGlow = 0;
                bossData.specialEffect = 0;
                
                // ç”»é¢å†…ã«åã‚ã‚‹
                if (bossData.x < 50) bossData.x = 50;
                if (bossData.x + bossData.width > canvas.width - 50) bossData.x = canvas.width - 50 - bossData.width;
                
                bosses.push(bossData);
            } catch (e) {
                console.error('Error spawning boss:', e);
                gameState.bossActive = false;
            }
        }
        
        function updateBosses() {
            for (let i = bosses.length - 1; i >= 0; i--) {
                try {
                    let boss = bosses[i];
                    if (!boss) continue;
                    
                    boss.moveTimer = (boss.moveTimer || 0) + 1;
                    boss.walkFrame = (boss.walkFrame || 0) + 0.08;
                    boss.eyeGlow = (boss.eyeGlow || 0) + 0.1;
                    
                    if (boss.y < 60) {
                        boss.y += boss.speed || 1;
                    } else {
                        if (boss.hp > boss.maxHp * 0.7) {
                            boss.x += Math.sin(boss.angle || 0) * 2;
                            boss.angle = (boss.angle || 0) + 0.02;
                        } else if (boss.hp > boss.maxHp * 0.3) {
                            boss.x = canvas.width/2 - boss.width/2 + Math.cos(boss.angle || 0) * 100;
                            boss.y = 80 + Math.sin((boss.angle || 0) * 0.7) * 30;
                            boss.angle = (boss.angle || 0) + 0.04;
                        } else {
                            if ((boss.moveTimer || 0) % 90 === 0) {
                                boss.x = Math.random() * (canvas.width - boss.width - 100) + 50;
                            }
                            boss.y = 60 + Math.sin(boss.angle || 0) * 40;
                            boss.angle = (boss.angle || 0) + 0.15;
                        }
                    }
                    
                    boss.shootCooldown = (boss.shootCooldown || 0) - 1;
                    if (boss.shootCooldown <= 0 && player) {
                        let centerX = boss.x + boss.width/2;
                        let centerY = boss.y + boss.height;
                        let bossLevel = gameState.bossesDefeated || 0;
                        
                        if (bossLevel === 0) {
                            // 1ä½“ç›®ï¼šã‚·ãƒ³ãƒ—ãƒ«ãªæ”»æ’ƒãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆæ”»ç•¥ã—ã‚„ã™ã„ï¼‰
                            if (boss.hp > boss.maxHp * 0.7) {
                                // å˜ç™ºã®ç‹™ã„æ’ƒã¡
                                let dx = (player.x || 0) - centerX;
                                let dy = (player.y || 0) - centerY;
                                let distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance > 0) {
                                    enemyBullets.push({
                                        x: centerX, y: centerY, width: 20, height: 20,
                                        vx: (dx / distance) * 2, vy: (dy / distance) * 2,
                                        color: boss.secondaryColor || '#FF0000', damage: 8
                                    });
                                }
                                boss.shootCooldown = 120; // ã‚†ã£ãã‚Š
                            } else if (boss.hp > boss.maxHp * 0.3) {
                                // 3æ–¹å‘å¼¾
                                for (let j = -1; j <= 1; j++) {
                                    let angle = Math.atan2((player.y || 0) - centerY, (player.x || 0) - centerX) + j * 0.3;
                                    enemyBullets.push({
                                        x: centerX, y: centerY, width: 18, height: 18,
                                        vx: Math.cos(angle) * 2.5, vy: Math.sin(angle) * 2.5,
                                        color: boss.accentColor || '#FF0000', damage: 10
                                    });
                                }
                                boss.shootCooldown = 100;
                            } else {
                                // 5æ–¹å‘å¼¾
                                for (let j = -2; j <= 2; j++) {
                                    let angle = Math.atan2((player.y || 0) - centerY, (player.x || 0) - centerX) + j * 0.2;
                                    enemyBullets.push({
                                        x: centerX, y: centerY, width: 16, height: 16,
                                        vx: Math.cos(angle) * 3, vy: Math.sin(angle) * 3,
                                        color: boss.glowColor || '#FF0000', damage: 12
                                    });
                                }
                                boss.shootCooldown = 80;
                            }
                        } else if (bossLevel === 1) {
                            // 2ä½“ç›®ï¼šä¸­ç¨‹åº¦ã®çŸ¥èƒ½ï¼ˆäºˆæ¸¬æ’ƒã¡è¿½åŠ ï¼‰
                            if (boss.hp > boss.maxHp * 0.7) {
                                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•ã‚’äºˆæ¸¬ã—ãŸæ’ƒã¡æ–¹
                                let predictX = (player.x || 0) + (keys['ArrowLeft'] ? -50 : keys['ArrowRight'] ? 50 : 0);
                                let predictY = (player.y || 0) + (keys['ArrowUp'] ? -50 : keys['ArrowDown'] ? 50 : 0);
                                let dx = predictX - centerX;
                                let dy = predictY - centerY;
                                let distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance > 0) {
                                    for (let k = 0; k < 3; k++) {
                                        enemyBullets.push({
                                            x: centerX + (k - 1) * 30, y: centerY, width: 22, height: 22,
                                            vx: (dx / distance) * 2.5, vy: (dy / distance) * 2.5,
                                            color: boss.secondaryColor || '#FF0000', damage: 10
                                        });
                                    }
                                }
                                boss.shootCooldown = 90;
                            } else if (boss.hp > boss.maxHp * 0.3) {
                                // å›è»¢å¼¾å¹•
                                let ringBullets = 8;
                                for (let j = 0; j < ringBullets; j++) {
                                    let angle = (j * Math.PI * 2) / ringBullets + (boss.angle || 0);
                                    enemyBullets.push({
                                        x: centerX, y: centerY, width: 20, height: 20,
                                        vx: Math.cos(angle) * 3, vy: Math.sin(angle) * 3,
                                        color: boss.accentColor || '#FF0000', damage: 12
                                    });
                                }
                                boss.shootCooldown = 70;
                            } else {
                                // ã‚¹ãƒ‘ã‚¤ãƒ©ãƒ«å¼¾å¹•
                                let spiralBullets = 12;
                                for (let j = 0; j < spiralBullets; j++) {
                                    let angle = (j * Math.PI * 2) / spiralBullets + (boss.angle || 0) * 2;
                                    enemyBullets.push({
                                        x: centerX, y: centerY, width: 18, height: 18,
                                        vx: Math.cos(angle) * 3.5, vy: Math.sin(angle) * 3.5,
                                        color: boss.glowColor || '#FF0000', damage: 14
                                    });
                                }
                                boss.shootCooldown = 50;
                            }
                        } else if (bossLevel === 2) {
                            // 3ä½“ç›®ï¼ˆæœ€çµ‚ãƒœã‚¹ï¼‰ï¼šé«˜ã„çŸ¥èƒ½ï¼ˆè¤‡åˆæ”»æ’ƒãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
                            if (boss.hp > boss.maxHp * 0.7) {
                                // è¤‡åˆæ”»æ’ƒï¼šäºˆæ¸¬æ’ƒã¡ + ã°ã‚‰ã¾ã
                                let predictX = (player.x || 0) + (keys['ArrowLeft'] ? -80 : keys['ArrowRight'] ? 80 : 0);
                                let predictY = (player.y || 0) + (keys['ArrowUp'] ? -80 : keys['ArrowDown'] ? 80 : 0);
                                
                                // äºˆæ¸¬å¼¾
                                let dx = predictX - centerX;
                                let dy = predictY - centerY;
                                let distance = Math.sqrt(dx * dx + dy * dy);
                                if (distance > 0) {
                                    for (let k = 0; k < 5; k++) {
                                        enemyBullets.push({
                                            x: centerX + (k - 2) * 25, y: centerY, width: 24, height: 24,
                                            vx: (dx / distance) * 3, vy: (dy / distance) * 3,
                                            color: boss.secondaryColor || '#FF0000', damage: 12
                                        });
                                    }
                                }
                                
                                // è¿½åŠ ã®ã°ã‚‰ã¾ãå¼¾
                                for (let k = 0; k < 8; k++) {
                                    let randomAngle = Math.random() * Math.PI * 2;
                                    enemyBullets.push({
                                        x: centerX, y: centerY, width: 20, height: 20,
                                        vx: Math.cos(randomAngle) * 2, vy: Math.sin(randomAngle) * 2,
                                        color: boss.accentColor || '#FF0000', damage: 10
                                    });
                                }
                                boss.shootCooldown = 80;
                            } else if (boss.hp > boss.maxHp * 0.3) {
                                // é«˜å¯†åº¦å›è»¢å¼¾å¹• + è¿½å°¾å¼¾
                                let ringBullets = 16;
                                for (let j = 0; j < ringBullets; j++) {
                                    let angle = (j * Math.PI * 2) / ringBullets + (boss.angle || 0);
                                    enemyBullets.push({
                                        x: centerX, y: centerY, width: 22, height: 22,
                                        vx: Math.cos(angle) * 3.5, vy: Math.sin(angle) * 3.5,
                                        color: boss.accentColor || '#FF0000', damage: 14
                                    });
                                }
                                
                                // è¿½å°¾å¼¾
                                let dx = (player.x || 0) - centerX;
                                let dy = (player.y || 0) - centerY;
                                let distance = Math.sqrt(dx * dx + dy * dy);
                                if (distance > 0) {
                                    enemyBullets.push({
                                        x: centerX, y: centerY, width: 28, height: 28,
                                        vx: (dx / distance) * 2, vy: (dy / distance) * 2,
                                        color: '#FF00FF', damage: 18
                                    });
                                }
                                boss.shootCooldown = 60;
                            } else {
                                // çµ¶æœ›å¼¾å¹•ï¼šå…¨æ–¹ä½ + ã‚¹ãƒ‘ã‚¤ãƒ©ãƒ« + è¿½å°¾
                                let ultimateBullets = 20;
                                for (let j = 0; j < ultimateBullets; j++) {
                                    let angle = (j * Math.PI * 2) / ultimateBullets + (boss.angle || 0) * 3;
                                    enemyBullets.push({
                                        x: centerX, y: centerY, width: 20, height: 20,
                                        vx: Math.cos(angle) * 4, vy: Math.sin(angle) * 4,
                                        color: boss.glowColor || '#FF0000', damage: 16
                                    });
                                }
                                
                                // è¤‡æ•°è¿½å°¾å¼¾
                                for (let k = 0; k < 3; k++) {
                                    let dx = (player.x || 0) - centerX + (k - 1) * 60;
                                    let dy = (player.y || 0) - centerY;
                                    let distance = Math.sqrt(dx * dx + dy * dy);
                                    if (distance > 0) {
                                        enemyBullets.push({
                                            x: centerX, y: centerY, width: 30, height: 30,
                                            vx: (dx / distance) * 2.5, vy: (dy / distance) * 2.5,
                                            color: '#FF00FF', damage: 20
                                        });
                                    }
                                }
                                boss.shootCooldown = 40;
                            }
                        }
                    }
                    
                    if (checkCollision(player, boss)) {
                        gameState.hp -= 25 + (gameState.bossesDefeated || 0) * 8; // ãƒ€ãƒ¡ãƒ¼ã‚¸å‰Šæ¸›
                        gameState.weaponLevel = 1;
                        
                        // é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰ã‚’è§£é™¤
                        gameState.speedModeTimer = 0;
                        gameState.isSpeedMode = false;
                        
                        // å¼·åŒ–ã•ã‚ŒãŸãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¨SEï¼ˆãƒœã‚¹æˆ¦ç‰ˆï¼‰
                        createPlayerDamageEffect(player.x + player.width/2, player.y + player.height/2);
                        if (musicEnabled && playerDamageSE && playerDamageSE2) {
                            try {
                                // ãƒœã‚¹æˆ¦ã¯ç‰¹ã«ç—›ã„ã®ã§ã€ã‚ˆã‚Šå¼·çƒˆãªSE
                                playerDamageSE.triggerAttackRelease("Bb4", "16n");
                                setTimeout(() => playerDamageSE.triggerAttackRelease("G4", "32n"), 40);
                                setTimeout(() => playerDamageSE.triggerAttackRelease("D3", "8n"), 80);
                                
                                // å¼·çƒˆãªãƒã‚¤ã‚ºSE
                                playerDamageSE2.triggerAttackRelease("8n");
                                
                                // ç¬¬3ã®ç—›ã¿SEï¼ˆãƒœã‚¹æˆ¦ç”¨ã«å¼·åŒ–ï¼‰
                                setTimeout(() => {
                                    if (playerDamageSE3) playerDamageSE3.triggerAttackRelease("F3", "16n");
                                }, 25);
                            } catch (e) {
                                console.warn('Error playing damage sound:', e);
                            }
                        }
                        
                        if (gameState.hp <= 0) {
                            if (gameState.continuesUsed < 5) {
                                gameState.showContinue = true;
                                continueTimer = 600; // 10ç§’ (60fps * 10)
                            } else {
                                gameState.gameOver = true;
                            }
                        }
                    }
                    
                    for (let j = bullets.length - 1; j >= 0; j--) {
                        if (checkCollision(bullets[j], boss)) {
                            boss.hp -= bullets[j].damage || 0;
                            
                            if (musicEnabled && enemyHitSE) {
                                try {
                                    // ãƒœã‚¹ãƒ’ãƒƒãƒˆSEï¼ˆã‚ˆã‚Šè¿«åŠ›ã®ã‚ã‚‹éŸ³ï¼‰
                                    enemyHitSE.triggerAttackRelease("B4", "64n");
                                    setTimeout(() => enemyHitSE.triggerAttackRelease("E5", "128n"), 12);
                                } catch (e) {
                                    console.warn('Error playing hit sound:', e);
                                }
                            }
                            
                            if (bullets[j].type !== 'mega_laser') {
                                bullets.splice(j, 1);
                            }
                            
                            createMakidenFireEffect(boss.x + boss.width/2, boss.y + boss.height/2);
                            
                            if (boss.hp <= 0) {
                                gameState.score += 10000 + (gameState.bossesDefeated || 0) * 3000;
                                gameState.bossesDefeated = (gameState.bossesDefeated || 0) + 1;
                                
                                // ãƒœã‚¹æ’ƒç ´æ™‚ã«æ”»æ’ƒç‰ã‚’å…¨ã¦ã‚¯ãƒªã‚¢
                                enemyBullets = [];
                                
                                for (let k = 0; k < 120; k++) {
                                    createMakidenFireEffect(boss.x + Math.random() * boss.width, boss.y + Math.random() * boss.height);
                                    createMakidenExplosion(boss.x + Math.random() * boss.width, boss.y + Math.random() * boss.height);
                                }
                                
                                // è¶…çˆ½å¿«ãƒœã‚¹æ’ƒç ´SEï¼ˆæœ€é«˜ã®æ°—æŒã¡ã‚ˆã•ï¼‰
                                if (musicEnabled && enemyDeathSE) {
                                    try {
                                        // ãƒ¡ã‚¤ãƒ³ã®å¤§çˆ†ç™ºéŸ³ï¼ˆãƒã‚¤ã‚ºï¼‰
                                        enemyDeathSE.triggerAttackRelease("4n");
                                        
                                        // å£®å¤§ãªä¸Šæ˜‡éŸ³éšï¼ˆãƒœã‚¹å°‚ç”¨ï¼‰
                                        if (enemyKillSE1) {
                                            enemyKillSE1.triggerAttackRelease("C3", "4n");
                                            setTimeout(() => enemyKillSE1.triggerAttackRelease("G3", "8n"), 60);
                                            setTimeout(() => enemyKillSE1.triggerAttackRelease("C4", "8n"), 120);
                                            setTimeout(() => enemyKillSE1.triggerAttackRelease("E4", "16n"), 180);
                                            setTimeout(() => enemyKillSE1.triggerAttackRelease("G4", "16n"), 220);
                                        }
                                        
                                        // é«˜éŸ³åŸŸã§ã®å‹åˆ©ã®éŸ³
                                        if (enemyKillSE2) {
                                            setTimeout(() => enemyKillSE2.triggerAttackRelease("C5", "2n"), 100);
                                            setTimeout(() => enemyKillSE2.triggerAttackRelease("G5", "4n"), 250);
                                        }
                                        
                                        // æœ€çµ‚çš„ãªå‹åˆ©ã®éŸ¿ãï¼ˆã‚­ãƒ©ã‚­ãƒ©é€£æ‰“ï¼‰
                                        if (enemyKillSE3) {
                                            for (let k = 0; k < 8; k++) {
                                                setTimeout(() => {
                                                    enemyKillSE3.triggerAttackRelease("C6", "64n");
                                                }, 200 + k * 30);
                                            }
                                        }
                                    } catch (e) {
                                        console.warn('Error playing boss death sound:', e);
                                    }
                                }
                                
                                for (let k = 0; k < 25; k++) {
                                    powerUps.push({
                                        x: boss.x + Math.random() * boss.width, y: boss.y + Math.random() * boss.height,
                                        width: 48, height: 48, speed: 2,
                                        type: Math.random() < 0.25 ? 'weapon' : (Math.random() < 0.5 ? 'health' : (Math.random() < 0.75 ? 'power' : 'laser_ammo')),
                                        angle: 0
                                    });
                                }
                                
                                bosses.splice(i, 1);
                                gameState.bossActive = false;
                                
                                if ((gameState.bossesDefeated || 0) >= 3) {
                                    gameState.gameCleared = true;
                                    gameState.showEnding = true;
                                    // å‹åˆ©BGMé–‹å§‹
                                    switchToVictoryMusic();
                                } else {
                                    // ãƒœã‚¹æ’ƒç ´å¾Œã¯å¿…ãšé€šå¸¸BGMã«æˆ»ã™
                                    isBossMusic = false;
                                    isFinalBossMusic = false;
                                    isVictoryMusic = false;
                                    switchToNormalMusic();
                                    changeStage();
                                }
                            }
                            break;
                        }
                    }
                } catch (e) {
                    console.error('Error updating boss:', e);
                    // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸãƒœã‚¹ã‚’å‰Šé™¤
                    bosses.splice(i, 1);
                    gameState.bossActive = false;
                }
            }
        }
        
        function spawnEnemy() {
            if (!gameState.bossActive && !gameState.gameCleared && gameState.gameStarted && Math.random() < gameState.enemySpawnRate) {
                let enemyType = Math.random();
                let enemy;
                
                if (enemyType < 0.25) { // ã‚³ã‚¦ãƒ¢ãƒª - é©åº¦ãªã‚µã‚¤ã‚º
                    // ã‚³ã‚¦ãƒ¢ãƒªã¯1-3åŒ¹ã®ç·¨éšŠã«å¤‰æ›´
                    let formationSize = Math.random() < 0.4 ? 1 : (Math.random() < 0.7 ? 2 : 3);
                    for (let f = 0; f < formationSize; f++) {
                        enemy = {
                            x: Math.random() * (canvas.width - 140) + 70 + (f * 40), // 3å€ã‚µã‚¤ã‚ºã«å¯¾å¿œ
                            y: -48, width: 48, height: 48, // 3å€ã‚µã‚¤ã‚º (16 * 3 = 48)
                            speed: 2.0 + Math.random() * 0.8, // ã‚ˆã‚Šé«˜é€Ÿã«
                            hp: 20, maxHp: 20, // HPã‚‚é©åº¦ã«
                            color: '#333333', type: 'bat', pattern: 'fly_dynamic', angle: f * 1.2, 
                            shootCooldown: 120 + Math.random() * 180,
                            amplitude: 150 + Math.random() * 100, // ã‚ˆã‚Šå¤§ããªæŒ¯å¹…
                            baseY: 0, formationOffset: f * Math.PI / 3,
                            swoopTimer: Math.random() * 300, // æ€¥é™ä¸‹ã‚¿ã‚¤ãƒãƒ¼
                            swoopActive: false
                        };
                        enemies.push(enemy);
                    }
                } else if (enemyType < 0.45) {
                    enemy = {
                        x: Math.random() < 0.5 ? -43 : canvas.width + 43, y: Math.random() * (canvas.height / 2), 
                        width: 43, height: 43, speed: 2.2 + Math.random(), // 1.2å€ã‚µã‚¤ã‚º & é«˜é€ŸåŒ–
                        hp: 60, maxHp: 60, color: '#4B0082', type: 'sine_flyer', pattern: 'sine_curve', angle: 0,
                        initialX: Math.random() < 0.5 ? -43 : canvas.width + 43, 
                        amplitude: 80 + Math.random() * 40, frequency: 0.03 + Math.random() * 0.02,
                        shootCooldown: 100 + Math.random() * 150
                    };
                    enemies.push(enemy);
                } else if (enemyType < 0.65) {
                    // åœ°ä¸Šã‚’æ­©ãæ•µ
                    enemy = {
                        x: Math.random() * (canvas.width - 120) + 60, y: -43, width: 43, height: 43, // 1.2å€ã‚µã‚¤ã‚º
                        speed: 1.4 + Math.random() * 0.6, // é«˜é€ŸåŒ–
                        hp: 50, maxHp: 50, color: '#8B4513', type: 'ground_walker', pattern: 'walk_straight', 
                        shootCooldown: 150 + Math.random() * 200,
                        walkFrame: Math.random() * Math.PI * 2, // æ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨
                        footLOffset: 0, footROffset: 0
                    };
                    enemies.push(enemy);
                } else if (enemyType < 0.8) {
                    // ã‚½ãƒ¼ãƒ‰æŠ•ã’é›‘é­šã‚­ãƒ£ãƒ©
                    enemy = {
                        x: Math.random() * (canvas.width - 120) + 60, y: -50, width: 50, height: 50,
                        speed: 1.0 + Math.random() * 0.4, // ã‚†ã£ãã‚Šç§»å‹•
                        hp: 80, maxHp: 80, color: '#4169E1', type: 'sword_thrower', pattern: 'walk_straight',
                        shootCooldown: 180 + Math.random() * 120, // ã‚½ãƒ¼ãƒ‰æŠ•ã’é–“éš”
                        walkFrame: Math.random() * Math.PI * 2,
                        swordCount: 0 // æŠ•ã’ãŸã‚½ãƒ¼ãƒ‰ã®æ•°
                    };
                    enemies.push(enemy);
                } else {
                    // çˆ†å¼¾é›‘é­šã‚­ãƒ£ãƒ©
                    enemy = {
                        x: Math.random() * (canvas.width - 120) + 60, y: -45, width: 45, height: 45,
                        speed: 0.8 + Math.random() * 0.3, // éå¸¸ã«ã‚†ã£ãã‚Šç§»å‹•
                        hp: 80, maxHp: 80, // HPã‚’40â†’80ã«å¼·åŒ–
                        color: '#8B0000', type: 'bomb_walker', pattern: 'walk_straight',
                        contactDamage: 40, // æ¥è§¦æ™‚ã®å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸
                        blinkTimer: 0, // ç‚¹æ»…ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨
                        walkFrame: Math.random() * Math.PI * 2
                    };
                    enemies.push(enemy);
                }
            }
        }
        
        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                let enemy = enemies[i];
                
                enemy.shootCooldown--;
                if (enemy.shootCooldown <= 0 && enemy.y > 0 && enemy.y < canvas.height - 100) {
                    let dx = player.x - enemy.x;
                    let dy = player.y - enemy.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (enemy.type === 'sword_thrower' && distance < 300) {
                        // ã‚½ãƒ¼ãƒ‰æŠ•ã’æ”»æ’ƒ
                        if (Math.random() < 0.2) {
                            enemyBullets.push({
                                x: enemy.x + enemy.width/2, y: enemy.y + enemy.height, 
                                width: 20, height: 8, // ã‚½ãƒ¼ãƒ‰å½¢çŠ¶
                                vx: (dx / distance) * 5, vy: (dy / distance) * 5, 
                                color: '#C0C0C0', damage: 12, type: 'sword',
                                angle: Math.atan2(dy, dx) // ã‚½ãƒ¼ãƒ‰ã®å‘ã
                            });
                            enemy.swordCount++;
                            enemy.shootCooldown = 200 + Math.random() * 100;
                        }
                    } else if (enemy.type !== 'sword_thrower' && enemy.type !== 'bomb_walker' && distance < 250 && Math.random() < 0.12) {
                        // é€šå¸¸ã®å¼¾æ”»æ’ƒ
                        enemyBullets.push({
                            x: enemy.x + enemy.width/2, y: enemy.y + enemy.height, width: 16, height: 16,
                            vx: (dx / distance) * 3.5, vy: (dy / distance) * 3.5, color: enemy.color, damage: 8
                        });
                        enemy.shootCooldown = 250 + Math.random() * 350;
                    }
                }
                
                switch (enemy.pattern) {
                    case 'walk_straight':
                        enemy.y += enemy.speed;
                        // åœ°ä¸Šã‚­ãƒ£ãƒ©ã®æ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                        enemy.walkFrame += 0.15;
                        enemy.footLOffset = Math.sin(enemy.walkFrame) * 4;
                        enemy.footROffset = Math.sin(enemy.walkFrame + Math.PI) * 4;
                        
                        // çˆ†å¼¾ã‚­ãƒ£ãƒ©ã®ç‚¹æ»…ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                        if (enemy.type === 'bomb_walker') {
                            enemy.blinkTimer += 0.2;
                        }
                        break;
                    case 'fly_dynamic': // ã‚³ã‚¦ãƒ¢ãƒªã®ãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯ãªå‹•ã
                        enemy.y += enemy.speed;
                        enemy.swoopTimer--;
                        
                        if (!enemy.swoopActive) {
                            // é€šå¸¸ã®è›‡è¡Œé£›è¡Œï¼ˆã‚ˆã‚Šå¤§ããï¼‰
                            if (!enemy.baseY) enemy.baseY = enemy.y;
                            enemy.x += Math.sin(enemy.angle + (enemy.formationOffset || 0)) * (enemy.amplitude / 20);
                            enemy.angle += 0.18; // ã‚ˆã‚Šé€Ÿã„å‹•ã
                            
                            // ãƒ©ãƒ³ãƒ€ãƒ ã§æ€¥é™ä¸‹é–‹å§‹
                            if (enemy.swoopTimer <= 0 && Math.random() < 0.02) {
                                enemy.swoopActive = true;
                                enemy.swoopTimer = 120; // 2ç§’é–“ã®æ€¥é™ä¸‹
                                enemy.swoopTargetX = player.x + (Math.random() - 0.5) * 100;
                            }
                        } else {
                            // æ€¥é™ä¸‹æ”»æ’ƒ
                            let dx = enemy.swoopTargetX - enemy.x;
                            enemy.x += dx * 0.05; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å‘ã‹ã£ã¦ç§»å‹•
                            enemy.y += enemy.speed * 2; // é€šå¸¸ã®2å€é€Ÿã§é™ä¸‹
                            
                            enemy.swoopTimer--;
                            if (enemy.swoopTimer <= 0) {
                                enemy.swoopActive = false;
                                enemy.swoopTimer = 180 + Math.random() * 240; // æ¬¡ã®æ€¥é™ä¸‹ã¾ã§3-7ç§’
                            }
                        }
                        break;
                    case 'sine_curve':
                        if (enemy.initialX < canvas.width / 2) {
                            enemy.x += enemy.speed;
                        } else {
                            enemy.x -= enemy.speed;
                        }
                        enemy.angle += enemy.frequency;
                        enemy.y += Math.sin(enemy.angle) * enemy.amplitude * 0.025;
                        break;
                }
                
                if (enemy.y > canvas.height + 100 || enemy.x < -enemy.width - 100 || enemy.x > canvas.width + 100) {
                    enemies.splice(i, 1);
                    continue;
                }
                
                if (checkCollision(player, enemy)) {
                    let contactDamage = enemy.contactDamage || 15; // çˆ†å¼¾ã‚­ãƒ£ãƒ©ã¯å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸ã€ä»–ã¯é€šå¸¸
                    gameState.hp -= contactDamage;
                    gameState.weaponLevel = 1;
                    
                    // é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰ã‚’è§£é™¤
                    gameState.speedModeTimer = 0;
                    gameState.isSpeedMode = false;
                    
                    // çˆ†å¼¾ã‚­ãƒ£ãƒ©ã®å ´åˆã¯å¤§çˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    if (enemy.type === 'bomb_walker') {
                        for (let k = 0; k < 30; k++) {
                            createMakidenExplosion(enemy.x + Math.random() * enemy.width, enemy.y + Math.random() * enemy.height);
                        }
                    }
                    
                    // å¼·åŒ–ã•ã‚ŒãŸãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¨ã€Œç—›ã„ï¼ã€SE
                    createPlayerDamageEffect(player.x + player.width/2, player.y + player.height/2);
                    if (musicEnabled && playerDamageSE && playerDamageSE2) {
                        try {
                            // ãƒ¡ã‚¤ãƒ³ã®ç—›ã¿SEï¼ˆé«˜éŸ³ã‹ã‚‰ä½éŸ³ã¸ã®ãƒ‰ãƒ©ãƒãƒãƒƒã‚¯ãªå¤‰åŒ–ï¼‰
                            playerDamageSE.triggerAttackRelease("G4", "16n");
                            setTimeout(() => playerDamageSE.triggerAttackRelease("E4", "32n"), 35);
                            setTimeout(() => playerDamageSE.triggerAttackRelease("C3", "16n"), 70);
                            
                            // è¿½åŠ ã®ãƒã‚¤ã‚ºSEï¼ˆç—›ã¿ã‚’å¼·èª¿ï¼‰
                            playerDamageSE2.triggerAttackRelease("16n");
                            
                            // ç¬¬3ã®ç—›ã¿SEï¼ˆé‡ã­ã¦è¿«åŠ›ã‚¢ãƒƒãƒ—ï¼‰
                            setTimeout(() => {
                                if (playerDamageSE3) playerDamageSE3.triggerAttackRelease("D3", "32n");
                            }, 18);
                        } catch (e) {
                            console.warn('Error playing damage sound:', e);
                        }
                    }
                    
                    enemies.splice(i, 1);
                    createMakidenExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                    
                    if (gameState.hp <= 0) {
                        if (gameState.continuesUsed < 5) {
                            gameState.showContinue = true;
                            continueTimer = 600; // 10ç§’ (60fps * 10)
                        } else {
                            gameState.gameOver = true;
                        }
                    }
                    continue;
                }
                
                for (let j = bullets.length - 1; j >= 0; j--) {
                    let collision = false;
                    
                    if (bullets[j].type === 'mega_laser') {
                        collision = (enemy.x < bullets[j].x + 60 && 
                                   enemy.x + enemy.width > bullets[j].x - 60 &&
                                   enemy.y < bullets[j].y + bullets[j].height && 
                                   enemy.y + enemy.height > 0);
                    } else {
                        collision = checkCollision(bullets[j], enemy);
                    }
                    
                    if (collision) {
                        enemy.hp -= bullets[j].damage;
                        
                        if (musicEnabled && enemyHitSE) {
                            try {
                                // æ•µãƒ’ãƒƒãƒˆSEï¼ˆæ°—æŒã¡ã„ãƒ’ãƒƒãƒˆéŸ³ï¼‰
                                enemyHitSE.triggerAttackRelease("B4", "64n");
                                setTimeout(() => enemyHitSE.triggerAttackRelease("D5", "128n"), 15);
                            } catch (e) {
                                console.warn('Error playing hit sound:', e);
                            }
                        }
                        
                        if (bullets[j].type !== 'mega_laser') {
                            bullets.splice(j, 1);
                        }
                        
                        createMakidenFireEffect(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                        
                        if (enemy.hp <= 0) {
                            gameState.score += enemy.maxHp;
                            
                            // çˆ†å¼¾ã‚­ãƒ£ãƒ©ã®å ´åˆã¯è¶…æ´¾æ‰‹ãªçˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                            if (enemy.type === 'bomb_walker') {
                                // å¤§çˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                                for (let k = 0; k < 50; k++) {
                                    createMakidenExplosion(enemy.x + Math.random() * enemy.width, enemy.y + Math.random() * enemy.height);
                                }
                                // è¿½åŠ ã®ç‚ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                                for (let k = 0; k < 30; k++) {
                                    createMakidenFireEffect(enemy.x + Math.random() * enemy.width, enemy.y + Math.random() * enemy.height);
                                }
                                // ç”»é¢éœ‡å‹•ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
                                for (let k = 0; k < 20; k++) {
                                    particles.push({
                                        x: enemy.x + enemy.width/2 + (Math.random() - 0.5) * 100,
                                        y: enemy.y + enemy.height/2 + (Math.random() - 0.5) * 100,
                                        vx: (Math.random() - 0.5) * 20,
                                        vy: (Math.random() - 0.5) * 20,
                                        life: 30, maxLife: 30,
                                        color: '#FFD700',
                                        type: 'bomb_explosion', size: 5 + Math.random() * 10
                                    });
                                }
                            } else {
                                createMakidenDeathEffect(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            }
                            
                            // æ°—æŒã¡ã„æ•µæ’ƒç ´SEï¼ˆè¤‡åˆéŸ³ã§çˆ½å¿«æ„Ÿæº€ç‚¹ï¼‰
                            if (musicEnabled && enemyDeathSE) {
                                try {
                                    // ãƒ¡ã‚¤ãƒ³ã®æ’ƒç ´éŸ³ï¼ˆãƒã‚¤ã‚ºï¼‰
                                    enemyDeathSE.triggerAttackRelease("8n");
                                    
                                    // çˆ½å¿«ãªä¸Šæ˜‡éŸ³éšï¼ˆä¸‰å’ŒéŸ³ã§æ°—æŒã¡ã‚ˆãï¼‰
                                    if (enemyKillSE1) {
                                        enemyKillSE1.triggerAttackRelease("C4", "8n");
                                        setTimeout(() => enemyKillSE1.triggerAttackRelease("E4", "16n"), 40);
                                        setTimeout(() => enemyKillSE1.triggerAttackRelease("G4", "16n"), 70);
                                    }
                                    
                                    // ã‚ˆã‚Šé«˜éŸ³åŸŸã§ã®çˆ½å¿«éŸ³
                                    if (enemyKillSE2) {
                                        setTimeout(() => enemyKillSE2.triggerAttackRelease("C5", "4n"), 60);
                                    }
                                    
                                    // æœ€å¾Œã®æ±ºã‚ã®éŸ³ï¼ˆã‚­ãƒ©ã‚­ãƒ©æ„Ÿï¼‰
                                    if (enemyKillSE3) {
                                        setTimeout(() => enemyKillSE3.triggerAttackRelease("G5", "32n"), 100);
                                        setTimeout(() => enemyKillSE3.triggerAttackRelease("C6", "64n"), 130);
                                    }
                                } catch (e) {
                                    console.warn('Error playing death sound:', e);
                                }
                            }
                            enemies.splice(i, 1);
                            
                            if (Math.random() < 0.3) {
                                spawnPowerUp(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            }
                        }
                        break;
                    }
                }
            }
        }
        
        function spawnPowerUp(x, y) {
            let type = Math.random();
            if (type < 0.4) { // ãƒ˜ãƒ«ã‚¹ç¢ºç‡ã‚’40%
                type = 'health';
            } else if (type < 0.7) { // ãƒ‘ãƒ¯ãƒ¼ç¢ºç‡ã‚’30%
                type = 'power';
            } else if (type < 0.9) { // ãƒ¬ãƒ¼ã‚¶ãƒ¼å¼¾ç¢ºç‡ã‚’20%
                type = 'laser_ammo';
            } else { // é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰ç¢ºç‡ã‚’10%
                type = 'speed_mode';
            }
            
            powerUps.push({
                x: x - 18, y: y, width: 36, height: 36, speed: 1.5, type: type, angle: 0
            });
        }
        
        function updatePowerUps() {
            for (let i = powerUps.length - 1; i >= 0; i--) {
                let powerUp = powerUps[i];
                powerUp.y += powerUp.speed;
                powerUp.angle += 0.1;
                
                if (powerUp.y > canvas.height) {
                    powerUps.splice(i, 1);
                    continue;
                }
                
                if (checkCollision(player, powerUp)) {
                    if (powerUp.type === 'health') {
                        gameState.hp = Math.min(60, gameState.hp + 20); // æœ€å¤§ä½“åŠ›ã‚’60ã«ã€å›å¾©é‡ã‚’30â†’20ã«èª¿æ•´
                        if (musicEnabled && healthItemSE) {
                            healthItemSE.triggerAttackRelease("C5", "4n");
                            setTimeout(() => healthItemSE.triggerAttackRelease("E5", "8n"), 100);
                        }
                    } else if (powerUp.type === 'power') {
                        gameState.score += 100;
                        if (musicEnabled && powerItemSE) {
                            powerItemSE.triggerAttackRelease("G5", "8n");
                            setTimeout(() => powerItemSE.triggerAttackRelease("C6", "16n"), 80);
                        }
                    } else if (powerUp.type === 'weapon') {
                        gameState.weaponLevel = Math.min(9, gameState.weaponLevel + 1);
                        if (musicEnabled && weaponUpSE) {
                            weaponUpSE.triggerAttackRelease("C6", "4n");
                            setTimeout(() => weaponUpSE.triggerAttackRelease("E6", "8n"), 100);
                            setTimeout(() => weaponUpSE.triggerAttackRelease("G6", "8n"), 200);
                        }
                    } else if (powerUp.type === 'laser_ammo') {
                        gameState.laserAmmo += 8; // 5ã‹ã‚‰8ã«å¢—é‡
                        if (musicEnabled && laserAmmoSE) {
                            laserAmmoSE.triggerAttackRelease("A5", "8n");
                            setTimeout(() => laserAmmoSE.triggerAttackRelease("D6", "16n"), 60);
                        }
                    } else if (powerUp.type === 'speed_mode') {
                        gameState.speedModeTimer = 300; // 5ç§’é–“ã«çŸ­ç¸®ï¼ˆ60fps * 5ï¼‰
                        gameState.isSpeedMode = true;
                        if (musicEnabled && speedModeActivateSE) {
                            speedModeActivateSE.triggerAttackRelease("C5", "2n");
                            setTimeout(() => speedModeActivateSE.triggerAttackRelease("E5", "4n"), 150);
                            setTimeout(() => speedModeActivateSE.triggerAttackRelease("G5", "4n"), 300);
                        }
                    }
                    powerUps.splice(i, 1);
                }
            }
        }
        
        function createFireballParticle(x, y) {
            particles.push({
                x: x + (Math.random() - 0.5) * 20,
                y: y + (Math.random() - 0.5) * 20,
                vx: (Math.random() - 0.5) * 6,
                vy: (Math.random() - 0.5) * 6,
                life: 15, maxLife: 15,
                color: `hsl(${Math.random() * 40 + 10}, 100%, ${60 + Math.random() * 30}%)`,
                type: 'fireball_particle', size: 2 + Math.random() * 3
            });
        }
        
        function createPlayerDamageEffect(x, y) {
            // ç”»é¢ã‚’å°‘ã—æŒ¯å‹•ã•ã›ã‚‹åŠ¹æœã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 30,
                    y: y + (Math.random() - 0.5) * 30,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12 - 2,
                    life: 40, maxLife: 40,
                    color: `hsl(0, 100%, ${70 + Math.random() * 20}%)`, // èµ¤ç³»
                    type: 'player_damage', size: 3 + Math.random() * 5
                });
            }
        }
        
        function createMakidenFireEffect(x, y) {
            for (let i = 0; i < 12; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 16, 
                    y: y + (Math.random() - 0.5) * 16,
                    vx: (Math.random() - 0.5) * 4, 
                    vy: -Math.random() * 8 - 2, // ä¸Šå‘ãã®ç‚
                    life: 25, maxLife: 25,
                    color: `hsl(${Math.random() * 60 + 10}, 100%, ${60 + Math.random() * 20}%)`,
                    type: 'makiden_fire', size: 2 + Math.random() * 4
                });
            }
        }
        
        function createMakidenDeathEffect(x, y) {
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 18, 
                    y: y + (Math.random() - 0.5) * 18,
                    vx: (Math.random() - 0.5) * 8, 
                    vy: -Math.random() * 10 - 3, // ã‚ˆã‚Šä¸Šå‘ã
                    life: 35, maxLife: 35,
                    color: `hsl(${Math.random() * 80 + 5}, 100%, ${50 + Math.random() * 30}%)`,
                    type: 'makiden_death', size: 3 + Math.random() * 6
                });
            }
        }
        
        function createMakidenExplosion(x, y) {
            for (let i = 0; i < 25; i++) {
                particles.push({
                    x: x, y: y, vx: (Math.random() - 0.5) * 20, vy: (Math.random() - 0.5) * 20,
                    life: 60, maxLife: 60, color: `hsl(${Math.random() * 60 + 15}, 100%, 50%)`,
                    type: 'makiden_explosion'
                });
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                p.vx *= 0.95;
                p.vy *= 0.95;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        function checkCollision(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                   obj1.x + obj1.width > obj2.x &&
                   obj1.y < obj2.y + obj2.height &&
                   obj1.y + obj1.height > obj2.y;
        }
        
        function updateBackground() {
            if (!gameState.gameStarted) return;
            
            gameState.backgroundOffset += gameState.scrollSpeed;
            gameState.totalDistance += gameState.scrollSpeed * 10; // ç§»å‹•è·é›¢ã‚’è¿½è·¡ï¼ˆ10å€ã‚¹ã‚±ãƒ¼ãƒ«ï¼‰
            
            if (gameState.backgroundOffset > 100) {
                gameState.backgroundOffset = 0;
                let newRow = [];
                // å·ã®å‡ºç¾ç‡ã‚’è·é›¢ã«å¿œã˜ã¦èª¿æ•´ï¼ˆåºç›¤ã¯å°‘ãªãã€ä¸­çµ‚ç›¤ã¯å¤šãï¼‰
                let riverChance = Math.min(0.15, gameState.totalDistance / 100000); // æœ€å¤§15%ã¾ã§å¢—åŠ 
                if (gameState.totalDistance < 3000) riverChance = 0.02; // åºç›¤ã¯2%ã®ã¿
                else if (gameState.totalDistance < 8000) riverChance = 0.05; // ä¸­ç›¤å‰ã¯5%
                else if (gameState.totalDistance < 15000) riverChance = 0.08; // ä¸­ç›¤ã¯8%
                
                // å‰ã®è¡ŒãŒå·ã ã£ãŸå ´åˆã¯å·ã‚’å‡ºç¾ã•ã›ãªã„
                let isRiverRow = !gameState.lastRowWasRiver && Math.random() < riverChance;
                let bridgePositions = [];
                
                if (isRiverRow) {
                    // å·ã®è¡Œã®å ´åˆã€1-3ç®‡æ‰€ã«æ©‹ã‚’é…ç½®
                    let bridgeCount = Math.random() < 0.4 ? 1 : (Math.random() < 0.7 ? 2 : 3);
                    for (let i = 0; i < bridgeCount; i++) {
                        let bridgeIndex = Math.floor(Math.random() * Math.floor((canvas.width - 100) / 100));
                        bridgePositions.push(bridgeIndex);
                    }
                }
                
                let tileIndex = 0;
                for (let x = 50; x < canvas.width - 50; x += 100) {
                    let tileType = 'grass';
                    
                    if (isRiverRow) {
                        if (bridgePositions.includes(tileIndex)) {
                            tileType = 'bridge';
                        } else {
                            tileType = 'river';
                        }
                    }
                    
                    newRow.push({ type: tileType, x: x, variation: Math.floor(Math.random() * 3) });
                    tileIndex++;
                }
                backgroundTiles.unshift({ y: -100, tiles: newRow });
                gameState.lastRowWasRiver = isRiverRow; // æ¬¡ã®è¡Œã®ãŸã‚ã«è¨˜éŒ²
            }
            
            for (let row of backgroundTiles) {
                row.y += gameState.scrollSpeed;
            }
            backgroundTiles = backgroundTiles.filter(row => row.y < canvas.height + 100);
        }
        
        function updateLevel() {
            let newLevel = Math.floor(gameState.score / 1000) + 1;
            if (newLevel > gameState.level) {
                gameState.level = newLevel;
                // æ•µå‡ºç¾ç‡ã‚’ç·©ã‚„ã‹ã«å¢—åŠ ï¼ˆå¾ŒåŠã®ã”ã¡ã‚ƒã”ã¡ã‚ƒæ„Ÿã‚’è»½æ¸›ï¼‰
                if (gameState.level <= 5) {
                    gameState.enemySpawnRate += 0.002; // åºç›¤ã¯ã‚†ã£ãã‚Š
                } else if (gameState.level <= 10) {
                    gameState.enemySpawnRate += 0.003; // ä¸­ç›¤ã‚‚æŠ‘åˆ¶
                } else {
                    gameState.enemySpawnRate += 0.004; // å¾ŒåŠã‚‚æ§ãˆã‚
                }
                gameState.scrollSpeed += 0.03; // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é€Ÿåº¦ã‚‚æ§ãˆã‚ã«
            }
        }
        
        function drawBackground() {
            let currentStageData = stages[gameState.currentStage];
            let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, currentStageData.skyTop);
            gradient.addColorStop(1, currentStageData.skyBottom);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // å·¦å³ã®æŸ±ã‚’æœ€åˆã«æç”»
            drawPillars();
            
            // æ”¹è‰¯ã•ã‚ŒãŸèƒŒæ™¯ï¼ˆã§ã“ã¼ã“ã—ãŸèŠç”Ÿã€å·ã€æ©‹ï¼‰
            for (let row of backgroundTiles) {
                for (let tile of row.tiles) {
                    let x = tile.x;
                    let y = row.y;
                    
                    if (tile.type === 'river') {
                        drawRiver(x, y, 100, 100);
                    } else if (tile.type === 'bridge') {
                        // æ©‹ã®ä¸‹ã®å·
                        drawRiver(x, y, 100, 100);
                        // æ©‹æœ¬ä½“
                        drawBridge(x, y, 100, 100);
                    } else {
                        // ã‚·ãƒ³ãƒ—ãƒ«ã§è¦‹ã‚„ã™ã„è‰åŸ
                        ctx.fillStyle = '#228B22';
                        ctx.fillRect(x, y, 100, 100);
                        
                        // ã•ã‚‰ã«ç´°ã„å¢ƒç•Œç·šã§è‡ªç„¶ãªæ„Ÿã˜ã‚’æ¼”å‡º
                        ctx.fillStyle = '#32CD32';
                        ctx.fillRect(x + 3, y + 3, 94, 94);
                        
                        // ã‚·ãƒ³ãƒ—ãƒ«ãªè‰ã®ç‚¹ã€…
                        ctx.fillStyle = '#228B22';
                        for (let gx = 15; gx < 95; gx += 20) {
                            for (let gy = 15; gy < 95; gy += 20) {
                                // å°ã•ãªè‰ã®ç‚¹ã‚’é…ç½®
                                ctx.fillRect(x + gx, y + gy, 2, 3);
                                ctx.fillRect(x + gx + 5, y + gy + 3, 2, 3);
                                ctx.fillRect(x + gx + 10, y + gy + 1, 2, 3);
                            }
                        }
                        
                        // ãŸã¾ã«å°ã•ãªèŠ±ã‚’é…ç½®ï¼ˆé »åº¦ã‚’ä¸‹ã’ã¦è¦‹ã‚„ã™ãï¼‰
                        if (Math.random() < 0.05) {
                            ctx.fillStyle = Math.random() < 0.5 ? '#FFD700' : '#FF69B4';
                            let flowerX = x + 30 + Math.random() * 40;
                            let flowerY = y + 30 + Math.random() * 40;
                            ctx.fillRect(flowerX, flowerY, 2, 2);
                        }
                    }
                }
            }
        }
        
        function draw() {
            try {
                drawBackground();
                
                // ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢è¡¨ç¤º
                if (!gameState.gameStarted) {
                    return;
                }
                
                // ï¼Ÿãƒœãƒƒã‚¯ã‚¹æç”»ï¼ˆãƒãƒãƒ­ãƒ³ã‚ˆã‚Šå…ˆã«æç”»ã—ã¦èƒŒé¢ã«ï¼‰
                for (let box of questionBoxes) {
                    try {
                        drawSprite('questionBox', box.x, box.y, 2.25); // 36/16 = 2.25å€ã‚µã‚¤ã‚º
                        
                        // ï¼Ÿãƒãƒ¼ã‚¯ã‚’èµ¤è‰²ã§æç”»ï¼ˆãƒœãƒƒã‚¯ã‚¹å†…ã«é©åˆ‡ã«é…ç½®ï¼‰
                        ctx.fillStyle = '#FF0000';
                        let qx = box.x + 10; // ãƒœãƒƒã‚¯ã‚¹å†…ã®ä¸­å¤®
                        let qy = box.y + 8;  // ãƒœãƒƒã‚¯ã‚¹å†…ã®é©åˆ‡ãªä½ç½®
                        let scale = 1.2; // ã‚µã‚¤ã‚ºã‚’å°ã•ãèª¿æ•´
                        
                        // ï¼Ÿãƒãƒ¼ã‚¯ã®ä¸Šã®ä¸¸ã„éƒ¨åˆ†ï¼ˆé©åˆ‡ãªã‚µã‚¤ã‚ºã§ï¼‰
                        ctx.fillRect(qx + 2*scale, qy + 1*scale, 6*scale, 2*scale);
                        ctx.fillRect(qx + 0*scale, qy + 3*scale, 2*scale, 3*scale);
                        ctx.fillRect(qx + 8*scale, qy + 3*scale, 2*scale, 3*scale);
                        ctx.fillRect(qx + 8*scale, qy + 6*scale, 2*scale, 2*scale);
                        ctx.fillRect(qx + 6*scale, qy + 8*scale, 2*scale, 2*scale);
                        ctx.fillRect(qx + 4*scale, qy + 10*scale, 2*scale, 2*scale);
                        
                        // ï¼Ÿãƒãƒ¼ã‚¯ã®ç‚¹ã®éƒ¨åˆ†
                        ctx.fillRect(qx + 4*scale, qy + 13*scale, 2*scale, 2*scale);
                        
                        if (box.hp < box.maxHp) {
                            ctx.fillStyle = '#FF0000';
                            ctx.fillRect(box.x, box.y - 10, box.width, 6);
                            ctx.fillStyle = '#00FF00';
                            ctx.fillRect(box.x + 2, box.y - 8, (box.width - 4) * (box.hp / box.maxHp), 2);
                        }
                    } catch (e) {
                        console.warn('Error drawing question box:', e);
                    }
                }
                
                // ãƒãƒãƒ­ãƒ³æç”»ï¼ˆæ”¹è‰¯ã•ã‚ŒãŸæ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰å¯¾å¿œï¼‰- æœ€å‰é¢  
                try {
                    // ä½“ã®ä¸Šä¸‹å‹•ã¨é ­ã®å·¦å³å‹•ã‚’é©ç”¨
                    let drawX = player.x + (player.headBob || 0);
                    let drawY = player.y + (player.bodyBounce || 0);
                    
                    // é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰æ™‚ã¯èµ¤ã„ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚’ä½¿ç”¨
                    let spriteKey = gameState.isSpeedMode ? 'popolon_speed' : 'popolon';
                    
                    // ãƒ¡ã‚¤ãƒ³ãƒœãƒ‡ã‚£ï¼ˆãƒ‰ãƒƒãƒˆçµµãƒ»2.25å€ã‚µã‚¤ã‚ºï¼‰
                    drawSprite(spriteKey, drawX, drawY, 2.25); // 36/16 = 2.25å€
                    
                    // é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    if (gameState.isSpeedMode) {
                        // æ®‹åƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                        ctx.fillRect(drawX - 10, drawY, player.width + 20, player.height);
                        
                        // ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ©ã‚¤ãƒ³
                        ctx.strokeStyle = '#FF6666';
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 8; i++) {
                            ctx.beginPath();
                            ctx.moveTo(drawX - 20 - i * 15, drawY + i * 5);
                            ctx.lineTo(drawX - 40 - i * 15, drawY + i * 5);
                            ctx.stroke();
                        }
                    }
                    
                    // è…•ã®æç”»ï¼ˆé‡åšãªé§ã®ã‚¢ãƒ¼ãƒ ã‚¬ãƒ¼ãƒ‰é¢¨ï¼‰
                    let armColor = gameState.isSpeedMode ? '#FF0000' : '#4169E1';
                    let armDetailColor = gameState.isSpeedMode ? '#FF6B6B' : '#87CEEB';
                    let shoulderColor = gameState.isSpeedMode ? '#FF1493' : '#1E90FF';
                    ctx.fillStyle = armColor;
                    
                    // å‘ãã«ã‚ˆã‚‹èª¿æ•´
                    let directionMultiplier = (player.facingDirection || 1) < 0 ? -1 : 1;
                    
                    // å·¦è‚©ã®ãƒ—ãƒ­ãƒ†ã‚¯ã‚¿ãƒ¼ï¼ˆé‡åšãªè‚©å½“ã¦ï¼‰
                    let leftShoulderX = drawX + 3 + (player.armLOffset || 0) * directionMultiplier * 0.5;
                    let leftShoulderY = drawY + 15;
                    ctx.fillStyle = shoulderColor;
                    ctx.fillRect(leftShoulderX, leftShoulderY, 10, 8);
                    ctx.fillStyle = '#FFD700'; // é‡‘ã®è£…é£¾
                    ctx.fillRect(leftShoulderX + 2, leftShoulderY + 2, 6, 2);
                    
                    // å³è‚©ã®ãƒ—ãƒ­ãƒ†ã‚¯ã‚¿ãƒ¼
                    let rightShoulderX = drawX + 23 + (player.armROffset || 0) * directionMultiplier * 0.5;
                    let rightShoulderY = drawY + 15;
                    ctx.fillStyle = shoulderColor;
                    ctx.fillRect(rightShoulderX, rightShoulderY, 10, 8);
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(rightShoulderX + 2, rightShoulderY + 2, 6, 2);
                    
                    // å·¦è…•ï¼ˆé‡åšãªã‚¢ãƒ¼ãƒ ã‚¬ãƒ¼ãƒ‰ï¼‰
                    let leftArmX = drawX + 5 + (player.armLOffset || 0) * directionMultiplier;
                    let leftArmY = drawY + 20 + Math.abs(player.armLOffset || 0) * 0.3;
                    ctx.fillStyle = armColor;
                    ctx.fillRect(leftArmX, leftArmY, 8, 16);
                    
                    // å·¦è…•ã®è£…é£¾ï¼ˆé‡‘å±ãƒ—ãƒ¬ãƒ¼ãƒˆï¼‰
                    ctx.fillStyle = armDetailColor;
                    ctx.fillRect(leftArmX + 1, leftArmY + 2, 6, 3);
                    ctx.fillRect(leftArmX + 1, leftArmY + 11, 6, 3);
                    
                    // å·¦æ‰‹ã®å…ˆï¼ˆé‡åšãªã‚¬ãƒ³ãƒˆãƒ¬ãƒƒãƒˆï¼‰
                    ctx.fillStyle = '#696969'; // é‹¼é‰„ã®ã‚¬ãƒ³ãƒˆãƒ¬ãƒƒãƒˆ
                    ctx.fillRect(leftArmX + 1, leftArmY + 14, 6, 6);
                    ctx.fillStyle = '#C0C0C0'; // ã‚·ãƒ«ãƒãƒ¼ã®è£…é£¾
                    ctx.fillRect(leftArmX + 2, leftArmY + 15, 4, 2);
                    
                    // å³è…•ï¼ˆé‡åšãªã‚¢ãƒ¼ãƒ ã‚¬ãƒ¼ãƒ‰ï¼‰
                    let rightArmX = drawX + 23 + (player.armROffset || 0) * directionMultiplier;
                    let rightArmY = drawY + 20 + Math.abs(player.armROffset || 0) * 0.3;
                    ctx.fillStyle = armColor;
                    ctx.fillRect(rightArmX, rightArmY, 8, 16);
                    
                    // å³è…•ã®è£…é£¾
                    ctx.fillStyle = armDetailColor;
                    ctx.fillRect(rightArmX + 1, rightArmY + 2, 6, 3);
                    ctx.fillRect(rightArmX + 1, rightArmY + 11, 6, 3);
                    
                    // å³æ‰‹ã®å…ˆï¼ˆé‡åšãªã‚¬ãƒ³ãƒˆãƒ¬ãƒƒãƒˆï¼‰
                    ctx.fillStyle = '#696969';
                    ctx.fillRect(rightArmX + 1, rightArmY + 14, 6, 6);
                    ctx.fillStyle = '#C0C0C0';
                    ctx.fillRect(rightArmX + 2, rightArmY + 15, 4, 2);
                    
                    // æ”¹è‰¯ã•ã‚ŒãŸè¶³ã®æç”»ï¼ˆé‡åšãªãƒ¬ãƒƒã‚°ã‚¬ãƒ¼ãƒ‰ï¼‰
                    ctx.fillStyle = armColor;
                    
                    // å·¦è¶³ï¼ˆé‡åšãªãƒ¬ãƒƒã‚°ãƒ—ãƒ¬ãƒ¼ãƒˆï¼‰
                    let leftFootX = drawX + 11 + (player.footLForward || 0);
                    let leftFootY = drawY + 36 + (player.footLOffset || 0);
                    ctx.fillRect(leftFootX, leftFootY, 10, 14);
                    
                    // å³è¶³
                    let rightFootX = drawX + 25 + (player.footRForward || 0);
                    let rightFootY = drawY + 36 + (player.footROffset || 0);
                    ctx.fillRect(rightFootX, rightFootY, 10, 14);
                    
                    // è¶³ã®è£…é£¾ï¼ˆãƒ¬ãƒƒã‚°ã‚¬ãƒ¼ãƒ‰ã®ãƒ—ãƒ¬ãƒ¼ãƒˆï¼‰
                    ctx.fillStyle = armDetailColor;
                    ctx.fillRect(leftFootX + 1, leftFootY + 2, 8, 3);
                    ctx.fillRect(rightFootX + 1, rightFootY + 2, 8, 3);
                    
                    // è¶³å…ˆã®æç”»ï¼ˆé‡åšãªé§ãƒ–ãƒ¼ãƒ„ï¼‰
                    ctx.fillStyle = '#2F4F4F'; // é‹¼é‰„è‰²ã®ãƒ–ãƒ¼ãƒ„
                    ctx.fillRect(leftFootX + 1, leftFootY + 10, 8, 4);
                    ctx.fillRect(rightFootX + 1, rightFootY + 10, 8, 4);
                    
                    // ãƒ–ãƒ¼ãƒ„ã®è£…é£¾ï¼ˆé‡‘ã®è£…é£¾ï¼‰
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(leftFootX + 3, leftFootY + 11, 4, 2);
                    ctx.fillRect(rightFootX + 3, rightFootY + 11, 4, 2);
                } catch (e) {
                    console.warn('Error drawing player:', e);
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šã‚·ãƒ³ãƒ—ãƒ«ãªæç”»
                    let spriteKey = gameState.isSpeedMode ? 'popolon_speed' : 'popolon';
                    drawSprite(spriteKey, player.x, player.y, 2.25);
                }
                
                // æ­¦å™¨å¼¾ä¸¸æç”»
                for (let bullet of bullets) {
                    try {
                        if (bullet.type === 'mega_laser') {
                            // ãƒ¬ãƒ¼ã‚¶ãƒ¼ã¯è‡ªã‚­ãƒ£ãƒ©ã‚ˆã‚Šå‰ã®ã¿æç”»
                            let alpha = bullet.intensity || 1.0;
                            let laserHeight = player.y; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚ˆã‚Šä¸Šã®ã¿
                            
                            ctx.fillStyle = `rgba(0, 255, 255, ${alpha * 0.3})`;
                            ctx.fillRect(bullet.x - 60, 0, 120, laserHeight);
                            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                            ctx.fillRect(bullet.x - 4, 0, 8, laserHeight);
                            
                            for (let i = 0; i < 20; i++) {
                                ctx.fillStyle = `rgba(0, 255, 255, ${alpha * 0.4})`;
                                ctx.fillRect(bullet.x - 70 + i * 7, 0, 4, laserHeight);
                            }
                        } else if (bullet.type === 'sword') {
                            ctx.fillStyle = bullet.color || '#FFFFFF';
                            ctx.fillRect(bullet.x - 4, bullet.y - 8, 8, 16);
                            ctx.fillRect(bullet.x - 2, bullet.y - 12, 4, 8);
                        } else if (bullet.type === 'flame') {
                            ctx.fillStyle = '#FF4500';
                            ctx.beginPath();
                            ctx.arc(bullet.x, bullet.y, 8, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = '#FFD700';
                            ctx.beginPath();
                            ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (bullet.type === 'thunder') {
                            ctx.strokeStyle = '#FFFF00';
                            ctx.lineWidth = 6;
                            ctx.beginPath();
                            ctx.moveTo(bullet.x, bullet.y - 12);
                            ctx.lineTo(bullet.x + Math.sin(bullet.zigzag || 0) * 12, bullet.y);
                            ctx.lineTo(bullet.x - Math.sin(bullet.zigzag || 0) * 8, bullet.y + 12);
                            ctx.stroke();
                        } else if (bullet.type === 'fireball') {
                            // è»Œè·¡ã‚’æç”»
                            if (bullet.trail) {
                                for (let t of bullet.trail) {
                                    let alpha = t.life / 15;
                                    ctx.fillStyle = `rgba(255, 100, 0, ${alpha * 0.6})`;
                                    ctx.beginPath();
                                    ctx.arc(t.x, t.y, 8 * alpha, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                            
                            // ãƒ¡ã‚¤ãƒ³ã®ç«ã®ç‰
                            let fireIntensity = Math.sin(bullet.fireEffect || 0) * 0.3 + 0.7;
                            
                            // å¤–å´ã®ç‚
                            ctx.fillStyle = `rgba(255, 69, 0, ${fireIntensity})`;
                            ctx.beginPath();
                            ctx.arc(bullet.x, bullet.y, 14, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // ä¸­é–“ã®ç‚
                            ctx.fillStyle = `rgba(255, 140, 0, ${fireIntensity})`;
                            ctx.beginPath();
                            ctx.arc(bullet.x, bullet.y, 10, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // æ ¸ã¨ãªã‚‹ç‚
                            ctx.fillStyle = `rgba(255, 215, 0, ${fireIntensity})`;
                            ctx.beginPath();
                            ctx.arc(bullet.x, bullet.y, 6, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // ä¸­å¿ƒã®ç™½ç†±éƒ¨
                            ctx.fillStyle = `rgba(255, 255, 255, ${fireIntensity * 0.8})`;
                            ctx.beginPath();
                            ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
                            ctx.fill();
                        } else {
                            ctx.fillStyle = bullet.color || '#FFFFFF';
                            ctx.fillRect(bullet.x - 4, bullet.y - 8, 8, 16);
                            ctx.fillRect(bullet.x - 2, bullet.y - 12, 4, 8);
                        }
                    } catch (e) {
                        console.warn('Error drawing bullet:', e);
                    }
                }
                
                // æ•µã®å¼¾ä¸¸æç”»ï¼ˆ2å€ã‚µã‚¤ã‚ºï¼‰
                for (let bullet of enemyBullets) {
                    try {
                        if (bullet.type === 'sword') {
                            // ã‚½ãƒ¼ãƒ‰å¼¾ã®æç”»
                            ctx.save();
                            ctx.translate(bullet.x, bullet.y);
                            ctx.rotate(bullet.angle || 0);
                            
                            // ã‚½ãƒ¼ãƒ‰ã®åˆƒ
                            ctx.fillStyle = '#C0C0C0';
                            ctx.fillRect(-10, -2, 16, 4);
                            
                            // ã‚½ãƒ¼ãƒ‰ã®æŸ„
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(-12, -1, 4, 2);
                            
                            // ã‚½ãƒ¼ãƒ‰ã®å…ˆç«¯
                            ctx.beginPath();
                            ctx.moveTo(6, 0);
                            ctx.lineTo(10, -2);
                            ctx.lineTo(10, 2);
                            ctx.closePath();
                            ctx.fillStyle = '#C0C0C0';
                            ctx.fill();
                            
                            ctx.restore();
                        } else {
                            // é€šå¸¸ã®å¼¾ä¸¸
                            ctx.fillStyle = bullet.color || '#FF0000';
                            ctx.beginPath();
                            ctx.arc(bullet.x, bullet.y, 10, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = '#FF0000';
                            ctx.beginPath();
                            ctx.arc(bullet.x, bullet.y, 6, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    } catch (e) {
                        console.warn('Error drawing enemy bullet:', e);
                    }
                }
                
                // ãƒœã‚¹æç”»ï¼ˆå¼·åŒ–ã‚µã‚¤ã‚ºï¼‰
                for (let boss of bosses) {
                    try {
                        if (!boss) continue;
                        
                        let hpBarHeight = Math.max(16, (boss.height || 240) * 0.04);
                        ctx.fillStyle = '#8B0000';
                        ctx.fillRect(boss.x || 0, (boss.y || 0) - hpBarHeight * 2, boss.width || 240, hpBarHeight);
                        ctx.fillStyle = '#FF0000';
                        ctx.fillRect((boss.x || 0) + 4, (boss.y || 0) - hpBarHeight * 2 + 4, (boss.width || 240) - 8, hpBarHeight - 8);
                        ctx.fillStyle = '#00FF00';
                        let hpRatio = Math.max(0, Math.min(1, (boss.hp || 0) / (boss.maxHp || 1)));
                        ctx.fillRect((boss.x || 0) + 4, (boss.y || 0) - hpBarHeight * 2 + 4, ((boss.width || 240) - 8) * hpRatio, hpBarHeight - 8);
                        
                        // ãƒœã‚¹ã‚¿ã‚¤ãƒ—åˆ¥æç”»
                        if (boss.type === 'medusa') {
                            // ãƒ¡ãƒ‡ãƒ¥ãƒ¼ã‚µã‚’ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã§æç”»
                            drawSprite('medusa', boss.x || 0, boss.y || 0, boss.spriteScale || 16.875);
                        } else {
                            // ãã®ä»–ã®ãƒœã‚¹ï¼ˆå¾“æ¥ã®æç”»ï¼‰
                            ctx.fillStyle = boss.color || '#8B0000';
                            ctx.fillRect(boss.x || 0, boss.y || 0, boss.width || 240, boss.height || 240);
                            
                            ctx.fillStyle = boss.secondaryColor || '#DC143C';
                            ctx.fillRect((boss.x || 0) + (boss.width || 240) * 0.2, (boss.y || 0) + (boss.height || 240) * 0.1, (boss.width || 240) * 0.6, (boss.height || 240) * 0.4);
                            
                            let eyeGlow = Math.sin(boss.eyeGlow || 0) * 0.5 + 0.5;
                            ctx.fillStyle = `rgba(255, 0, 0, ${0.8 + eyeGlow * 0.2})`;
                            ctx.fillRect((boss.x || 0) + (boss.width || 240) * 0.3, (boss.y || 0) + (boss.height || 240) * 0.2, (boss.width || 240) * 0.1, (boss.height || 240) * 0.1);
                            ctx.fillRect((boss.x || 0) + (boss.width || 240) * 0.6, (boss.y || 0) + (boss.height || 240) * 0.2, (boss.width || 240) * 0.1, (boss.height || 240) * 0.1);
                            
                            ctx.fillStyle = '#000000';
                            ctx.fillRect((boss.x || 0) + (boss.width || 240) * 0.35, (boss.y || 0) + (boss.height || 240) * 0.35, (boss.width || 240) * 0.3, (boss.height || 240) * 0.1);
                            
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillRect((boss.x || 0) + (boss.width || 240) * 0.4, (boss.y || 0) + (boss.height || 240) * 0.35, (boss.width || 240) * 0.03, (boss.height || 240) * 0.08);
                            ctx.fillRect((boss.x || 0) + (boss.width || 240) * 0.57, (boss.y || 0) + (boss.height || 240) * 0.35, (boss.width || 240) * 0.03, (boss.height || 240) * 0.08);
                            
                            ctx.fillStyle = boss.accentColor || '#FF6347';
                            ctx.fillRect((boss.x || 0) + (boss.width || 240) * 0.1, (boss.y || 0) + (boss.height || 240) * 0.5, (boss.width || 240) * 0.8, (boss.height || 240) * 0.4);
                            
                            ctx.fillStyle = boss.color || '#8B0000';
                            ctx.fillRect((boss.x || 0) - (boss.width || 240) * 0.1, (boss.y || 0) + (boss.height || 240) * 0.3, (boss.width || 240) * 0.2, (boss.height || 240) * 0.3);
                            ctx.fillRect((boss.x || 0) + (boss.width || 240) * 0.9, (boss.y || 0) + (boss.height || 240) * 0.3, (boss.width || 240) * 0.2, (boss.height || 240) * 0.3);
                        }
                        
                        // ã‚ªãƒ¼ãƒ©ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆå®‰å…¨ãªå‡¦ç†ï¼‰
                        let auraSize = (boss.width || 240)/2 + 30 + Math.sin(Date.now() * 0.008) * 20;
                        ctx.fillStyle = 'rgba(139, 0, 0, 0.15)';
                        ctx.beginPath();
                        ctx.arc((boss.x || 0) + (boss.width || 240)/2, (boss.y || 0) + (boss.height || 240)/2, auraSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                        ctx.beginPath();
                        ctx.arc((boss.x || 0) + (boss.width || 240)/2, (boss.y || 0) + (boss.height || 240)/2, auraSize + 30, 0, Math.PI * 2);
                        ctx.fill();
                    } catch (e) {
                        console.warn('Error drawing boss:', e);
                    }
                }
                
                // æ•µæç”»ï¼ˆãƒ‰ãƒƒãƒˆçµµãƒ»ã‚µã‚¤ã‚ºèª¿æ•´ï¼‰
                for (let enemy of enemies) {
                    try {
                        // é£›è¡Œæ•µã®ä¸¸å½±æç”»
                        if (enemy.type === 'bat' || enemy.type === 'sine_flyer') {
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                            ctx.beginPath();
                            let shadowSize = enemy.width * 0.6;
                            // ã‚³ã‚¦ãƒ¢ãƒªã®å½±ã¯3å€ã«å¯¾å¿œ
                            if (enemy.type === 'bat') {
                                shadowSize = enemy.width * 0.7; // ã‚³ã‚¦ãƒ¢ãƒªã®å½±
                            }
                            ctx.ellipse(enemy.x + enemy.width/2, enemy.y + enemy.height + 10, shadowSize/2, shadowSize/4, 0, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        if (enemy.hp < enemy.maxHp) {
                            ctx.fillStyle = '#FF0000';
                            ctx.fillRect(enemy.x, enemy.y - 9, enemy.width, 6);
                            ctx.fillStyle = '#00FF00';
                            ctx.fillRect(enemy.x + 2, enemy.y - 7, (enemy.width - 2) * (enemy.hp / enemy.maxHp), 2);
                        }
                        
                        if (enemy.type === 'bat') {
                            drawSprite('bat', enemy.x, enemy.y, 3); // 3å€ã‚µã‚¤ã‚º
                        } else if (enemy.type === 'sine_flyer') {
                            ctx.fillStyle = enemy.color || '#4B0082';
                            ctx.fillRect(enemy.x + 7, enemy.y + 7, 43, 43); // 1.2å€ã‚µã‚¤ã‚º
                            
                            ctx.fillStyle = '#6A5ACD';
                            let wingAngle = Math.sin(enemy.angle || 0) * 6;
                            ctx.fillRect(enemy.x, enemy.y + 14 + wingAngle, 14, 22); // 1.2å€
                            ctx.fillRect(enemy.x + 43, enemy.y + 14 - wingAngle, 14, 22); // 1.2å€
                            
                            ctx.fillStyle = '#FFFF00';
                            ctx.fillRect(enemy.x + 18, enemy.y + 14, 4, 4); // 1.2å€
                            ctx.fillRect(enemy.x + 36, enemy.y + 14, 4, 4); // 1.2å€
                        } else if (enemy.type === 'sword_thrower') {
                            // ã‚½ãƒ¼ãƒ‰æŠ•ã’é›‘é­šã‚­ãƒ£ãƒ©ï¼ˆã‚«ãƒƒã‚³ã„ã„é¨å£«é¢¨ï¼‰
                            
                            // é¨å£«ã®ãƒ¡ã‚¤ãƒ³ãƒœãƒ‡ã‚£ï¼ˆæ¿ƒã„é’ã®é§ï¼‰
                            ctx.fillStyle = '#191970';
                            ctx.fillRect(enemy.x + 5, enemy.y + 15, enemy.width - 10, enemy.height - 20);
                            
                            // é§ã®ãƒ—ãƒ¬ãƒ¼ãƒˆè£…é£¾ï¼ˆã‚·ãƒ«ãƒãƒ¼ï¼‰
                            ctx.fillStyle = '#C0C0C0';
                            ctx.fillRect(enemy.x + 8, enemy.y + 18, enemy.width - 16, 8);
                            ctx.fillRect(enemy.x + 8, enemy.y + 28, enemy.width - 16, 6);
                            ctx.fillRect(enemy.x + 8, enemy.y + 36, enemy.width - 16, 6);
                            
                            // èƒ¸éƒ¨ã®ç´‹ç« ï¼ˆé‡‘è‰²ï¼‰
                            ctx.fillStyle = '#FFD700';
                            ctx.fillRect(enemy.x + enemy.width/2 - 4, enemy.y + 20, 8, 8);
                            ctx.fillStyle = '#FF0000';
                            ctx.fillRect(enemy.x + enemy.width/2 - 2, enemy.y + 22, 4, 4);
                            
                            // ã‚«ãƒƒã‚³ã„ã„ãƒ˜ãƒ«ãƒ¡ãƒƒãƒˆï¼ˆã‚·ãƒ«ãƒãƒ¼ãƒ™ãƒ¼ã‚¹ï¼‰
                            ctx.fillStyle = '#C0C0C0';
                            ctx.fillRect(enemy.x + 8, enemy.y + 2, enemy.width - 16, 18);
                            
                            // ãƒ˜ãƒ«ãƒ¡ãƒƒãƒˆã®è£…é£¾ï¼ˆé‡‘ã®ãƒ©ã‚¤ãƒ³ï¼‰
                            ctx.fillStyle = '#FFD700';
                            ctx.fillRect(enemy.x + 10, enemy.y + 4, enemy.width - 20, 2);
                            ctx.fillRect(enemy.x + 10, enemy.y + 16, enemy.width - 20, 2);
                            
                            // ãƒã‚¤ã‚¶ãƒ¼ï¼ˆæ¿ƒã„ã‚°ãƒ¬ãƒ¼ï¼‰
                            ctx.fillStyle = '#2F2F2F';
                            ctx.fillRect(enemy.x + 12, enemy.y + 8, enemy.width - 24, 6);
                            
                            // èµ¤ã„ç›®ï¼ˆãƒã‚¤ã‚¶ãƒ¼ã®éš™é–“ã‹ã‚‰å…‰ã‚‹ï¼‰
                            ctx.fillStyle = '#FF0000';
                            ctx.fillRect(enemy.x + 16, enemy.y + 10, 3, 2);
                            ctx.fillRect(enemy.x + enemy.width - 19, enemy.y + 10, 3, 2);
                            
                            // è‚©ã®è£…ç”²ï¼ˆé‡åšæ„Ÿï¼‰
                            ctx.fillStyle = '#4169E1';
                            ctx.fillRect(enemy.x + 2, enemy.y + 12, 8, 12);
                            ctx.fillRect(enemy.x + enemy.width - 10, enemy.y + 12, 8, 12);
                            
                            // ã‚«ãƒƒã‚³ã„ã„ã‚½ãƒ¼ãƒ‰ï¼ˆæ‰‹ã«æŒã£ã¦ã„ã‚‹ï¼‰
                            ctx.fillStyle = '#C0C0C0'; // åˆƒ
                            ctx.fillRect(enemy.x + enemy.width - 6, enemy.y + 8, 3, 20);
                            
                            // ã‚½ãƒ¼ãƒ‰ã®ã‚¬ãƒ¼ãƒ‰ï¼ˆé”ï¼‰
                            ctx.fillStyle = '#FFD700';
                            ctx.fillRect(enemy.x + enemy.width - 8, enemy.y + 26, 7, 3);
                            
                            // ã‚½ãƒ¼ãƒ‰ã®æŸ„
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(enemy.x + enemy.width - 6, enemy.y + 29, 3, 8);
                            
                            // ã‚½ãƒ¼ãƒ‰ã®æŸ„é ­ï¼ˆãƒãƒ³ãƒ¡ãƒ«ï¼‰
                            ctx.fillStyle = '#FFD700';
                            ctx.fillRect(enemy.x + enemy.width - 7, enemy.y + 37, 5, 3);
                            
                            // ãƒãƒ³ãƒˆï¼ˆèƒŒå¾Œã«æµã‚Œã‚‹ï¼‰
                            ctx.fillStyle = '#8B0000';
                            ctx.fillRect(enemy.x - 2, enemy.y + 20, 6, enemy.height - 25);
                            
                            // é‡åšãªè„šéƒ¨è£…ç”²
                            ctx.fillStyle = '#191970';
                            let leftLegX = enemy.x + 12;
                            let leftLegY = enemy.y + enemy.height - 12 + (enemy.footLOffset || 0);
                            ctx.fillRect(leftLegX, leftLegY, 10, 12);
                            
                            let rightLegX = enemy.x + 28;
                            let rightLegY = enemy.y + enemy.height - 12 + (enemy.footROffset || 0);
                            ctx.fillRect(rightLegX, rightLegY, 10, 12);
                            
                            // è„šéƒ¨è£…ç”²ã®è£…é£¾
                            ctx.fillStyle = '#C0C0C0';
                            ctx.fillRect(leftLegX + 2, leftLegY + 2, 6, 2);
                            ctx.fillRect(rightLegX + 2, rightLegY + 2, 6, 2);
                        } else if (enemy.type === 'bomb_walker') {
                            // çˆ†å¼¾é›‘é­šã‚­ãƒ£ãƒ©ï¼ˆèµ¤é»’ç‚¹æ»…ï¼‰
                            let blinkPhase = Math.sin(enemy.blinkTimer || 0);
                            
                            // èµ¤ã¨é»’ã®é–“ã§ç‚¹æ»…
                            let bombColor;
                            if (blinkPhase > 0) {
                                // èµ¤ãƒ•ã‚§ãƒ¼ã‚º
                                let redIntensity = Math.abs(blinkPhase);
                                bombColor = `rgb(${Math.floor(139 + redIntensity * 116)}, 0, 0)`;
                            } else {
                                // é»’ãƒ•ã‚§ãƒ¼ã‚º
                                let blackIntensity = Math.abs(blinkPhase);
                                bombColor = `rgb(${Math.floor(40 * (1 - blackIntensity))}, 0, 0)`;
                            }
                            
                            // çˆ†å¼¾æœ¬ä½“ï¼ˆèµ¤é»’ç‚¹æ»…ï¼‰
                            ctx.fillStyle = bombColor;
                            ctx.beginPath();
                            ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.width/2, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // çˆ†å¼¾ã®ç¸«ã„ç›®æ¨¡æ§˜
                            ctx.fillStyle = '#000000';
                            ctx.fillRect(enemy.x + enemy.width/2 - 1, enemy.y + 8, 2, enemy.height - 16);
                            ctx.fillRect(enemy.x + 8, enemy.y + enemy.height/2 - 1, enemy.width - 16, 2);
                            
                            // å°ç«ç·šï¼ˆã‚ˆã‚Šå¤ªãç›®ç«‹ã¤ã‚ˆã†ã«ï¼‰
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(enemy.x + enemy.width/2 - 2, enemy.y - 8, 4, 12);
                            
                            // æ¿€ã—ã„ç«èŠ±ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆç‚¹æ»…ã«åˆã‚ã›ã¦ï¼‰
                            if (Math.random() < 0.5) {
                                ctx.fillStyle = blinkPhase > 0 ? '#FFD700' : '#FF4500';
                                for (let spark = 0; spark < 3; spark++) {
                                    ctx.beginPath();
                                    ctx.arc(
                                        enemy.x + enemy.width/2 + (Math.random() - 0.5) * 12, 
                                        enemy.y - 4 + Math.random() * 8, 
                                        1 + Math.random() * 2, 
                                        0, Math.PI * 2
                                    );
                                    ctx.fill();
                                }
                            }
                            
                            // æ­©è¡Œã™ã‚‹è¶³ï¼ˆå°ã•ã‚ã€é»’ã„é´ï¼‰
                            ctx.fillStyle = '#000000';
                            let leftFootX = enemy.x + 8;
                            let leftFootY = enemy.y + enemy.height - 5 + (enemy.footLOffset || 0);
                            ctx.fillRect(leftFootX, leftFootY, 8, 5);
                            
                            let rightFootX = enemy.x + 29;
                            let rightFootY = enemy.y + enemy.height - 5 + (enemy.footROffset || 0);
                            ctx.fillRect(rightFootX, rightFootY, 8, 5);
                        } else if (enemy.type === 'ground_walker') {
                            // åœ°ä¸Šã‚’æ­©ãã‚­ãƒ£ãƒ©ï¼ˆæ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãï¼‰
                            ctx.fillStyle = enemy.color || '#8B4513';
                            ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height - 7); // 1.2å€èª¿æ•´
                            
                            ctx.fillStyle = '#654321';
                            ctx.fillRect(enemy.x + 7, enemy.y + 7, enemy.width - 14, enemy.height - 22); // 1.2å€èª¿æ•´
                            
                            ctx.fillStyle = '#FF0000';
                            ctx.fillRect(enemy.x + 14, enemy.y + 14, 7, 7); // 1.2å€
                            ctx.fillRect(enemy.x + 36, enemy.y + 14, 7, 7); // 1.2å€
                            
                            // æ­©è¡Œã™ã‚‹è¶³
                            ctx.fillStyle = '#654321';
                            let leftFootX = enemy.x + 10;
                            let leftFootY = enemy.y + enemy.height - 7 + (enemy.footLOffset || 0);
                            ctx.fillRect(leftFootX, leftFootY, 10, 7); // 1.2å€
                            
                            let rightFootX = enemy.x + 24;
                            let rightFootY = enemy.y + enemy.height - 7 + (enemy.footROffset || 0);
                            ctx.fillRect(rightFootX, rightFootY, 10, 7); // 1.2å€
                        } else {
                            ctx.fillStyle = enemy.color || '#8B4513';
                            ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                            
                            ctx.fillStyle = '#654321';
                            ctx.fillRect(enemy.x + 7, enemy.y + 7, enemy.width - 14, enemy.height - 14); // 1.2å€èª¿æ•´
                            
                            ctx.fillStyle = '#FF0000';
                            ctx.fillRect(enemy.x + 14, enemy.y + 14, 7, 7); // 1.2å€
                            ctx.fillRect(enemy.x + 36, enemy.y + 14, 7, 7); // 1.2å€
                        }
                    } catch (e) {
                        console.warn('Error drawing enemy:', e);
                    }
                }
                
                // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—æç”»ï¼ˆ3å€ã‚µã‚¤ã‚ºï¼‰
                for (let powerUp of powerUps) {
                    try {
                        ctx.save();
                        ctx.translate(powerUp.x + powerUp.width/2, powerUp.y + powerUp.height/2);
                        ctx.rotate(powerUp.angle || 0);
                        
                        if (powerUp.type === 'health') {
                            ctx.fillStyle = '#FF6B6B';
                            ctx.fillRect(-18, -18, 36, 36);
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillRect(-3, -15, 6, 30);
                            ctx.fillRect(-15, -3, 30, 6);
                        } else if (powerUp.type === 'power') {
                            ctx.fillStyle = '#FFD700';
                            ctx.beginPath();
                            for (let i = 0; i < 5; i++) {
                                let angle = (i * Math.PI * 2) / 5;
                                let x = 18 * Math.cos(angle);
                                let y = 18 * Math.sin(angle);
                                if (i === 0) ctx.moveTo(x, y);
                                else ctx.lineTo(x, y);
                            }
                            ctx.closePath();
                            ctx.fill();
                        } else if (powerUp.type === 'weapon') {
                            ctx.fillStyle = '#4169E1';
                            ctx.fillRect(-18, -18, 36, 36);
                            ctx.fillStyle = '#87CEEB';
                            ctx.fillRect(-15, -15, 30, 30);
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = '24px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('W', 0, 6);
                        } else if (powerUp.type === 'laser_ammo') {
                            ctx.fillStyle = '#00FFFF';
                            ctx.fillRect(-18, -18, 36, 36);
                            ctx.fillStyle = '#87CEEB';
                            ctx.fillRect(-15, -15, 30, 30);
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = '24px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('L', 0, 6);
                        } else if (powerUp.type === 'speed_mode') {
                            ctx.fillStyle = '#FF0000';
                            ctx.fillRect(-18, -18, 36, 36);
                            ctx.fillStyle = '#FF6666';
                            ctx.fillRect(-15, -15, 30, 30);
                            ctx.fillStyle = '#FFFFFF';
                            ctx.font = '24px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('S', 0, 6);
                        }
                        
                        ctx.restore();
                    } catch (e) {
                        console.warn('Error drawing powerup:', e);
                    }
                }
                
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æç”»ï¼ˆ3å€ã‚µã‚¤ã‚ºï¼‰
                for (let p of particles) {
                    try {
                        let alpha = p.life / p.maxLife;
                        
                        if (p.type === 'makiden_fire') {
                            // å®‰å…¨ãªè‰²å‡¦ç†
                            let colorStr = p.color;
                            if (colorStr && colorStr.includes('hsl')) {
                                colorStr = colorStr.replace('hsl', 'hsla').replace(')', `, ${alpha})`);
                            } else {
                                colorStr = `rgba(255, 100, 0, ${alpha})`;
                            }
                            ctx.fillStyle = colorStr;
                            ctx.fillRect(p.x - (p.size || 3), p.y - (p.size || 3) * 2, (p.size || 3) * 2, (p.size || 3) * 4);
                            
                            ctx.fillStyle = `rgba(255, 200, 100, ${alpha})`;
                            ctx.fillRect(p.x - (p.size || 3)/2, p.y - (p.size || 3), (p.size || 3), (p.size || 3) * 2);
                        } else if (p.type === 'makiden_death') {
                            let colorStr = p.color;
                            if (colorStr && colorStr.includes('hsl')) {
                                colorStr = colorStr.replace('hsl', 'hsla').replace(')', `, ${alpha})`);
                            } else {
                                colorStr = `rgba(255, 150, 0, ${alpha})`;
                            }
                            ctx.fillStyle = colorStr;
                            ctx.fillRect(p.x - (p.size || 3), p.y - (p.size || 3), (p.size || 3) * 2, (p.size || 3) * 2);
                            
                            ctx.fillStyle = `rgba(255, 255, 150, ${alpha * 0.8})`;
                            ctx.fillRect(p.x - (p.size || 3)/2, p.y - (p.size || 3)/2, (p.size || 3), (p.size || 3));
                        } else if (p.type === 'player_damage') {
                            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆèµ¤ã„çˆ†ç™ºï¼‰
                            let colorStr = p.color;
                            if (colorStr && colorStr.includes('hsl')) {
                                colorStr = colorStr.replace('hsl', 'hsla').replace(')', `, ${alpha})`);
                            } else {
                                colorStr = `rgba(255, 0, 0, ${alpha})`;
                            }
                            ctx.fillStyle = colorStr;
                            ctx.fillRect(p.x - (p.size || 3), p.y - (p.size || 3), (p.size || 3) * 2, (p.size || 3) * 2);
                            
                            // ç™½ã„ä¸­å¿ƒéƒ¨
                            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.7})`;
                            ctx.fillRect(p.x - (p.size || 3)/2, p.y - (p.size || 3)/2, (p.size || 3), (p.size || 3));
                        } else if (p.type === 'fireball_particle') {
                            // ãƒ•ã‚¡ã‚¤ãƒ¤ãƒ¼ãƒœãƒ¼ãƒ«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
                            let colorStr = p.color;
                            if (colorStr && colorStr.includes('hsl')) {
                                colorStr = colorStr.replace('hsl', 'hsla').replace(')', `, ${alpha})`);
                            } else {
                                colorStr = `rgba(255, 100, 0, ${alpha})`;
                            }
                            ctx.fillStyle = colorStr;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, (p.size || 3) * alpha, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (p.type === 'bomb_explosion') {
                            // çˆ†å¼¾çˆ†ç™ºãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
                            ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, (p.size || 5) * alpha, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // å†…å´ã®ç™½ã„å…‰
                            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, (p.size || 5) * alpha * 0.5, 0, Math.PI * 2);
                            ctx.fill();
                        } else {
                            let colorStr = p.color;
                            if (colorStr && colorStr.includes('hsl')) {
                                colorStr = colorStr.replace('hsl', 'hsla').replace(')', `, ${alpha})`);
                            } else {
                                colorStr = `rgba(255, 100, 0, ${alpha})`;
                            }
                            ctx.fillStyle = colorStr;
                            ctx.fillRect(p.x - 3, p.y - 3, 6, 6);
                        }
                    } catch (e) {
                        console.warn('Error drawing particle:', e);
                    }
                }
            } catch (e) {
                console.error('Error in main draw function:', e);
            }
        }
        
        function updateUI() {
            try {
                const scoreElement = document.getElementById('score');
                const hpElement = document.getElementById('hp');
                const levelElement = document.getElementById('level');
                const stageElement = document.getElementById('stage');
                const weaponElement = document.getElementById('weapon');
                const laserElement = document.getElementById('laser');
                const gameOverElement = document.getElementById('gameOver');
                const endingElement = document.getElementById('endingScreen');
                const continueElement = document.getElementById('continueScreen');
                const continueCountElement = document.getElementById('continueCount');
                const speedModeElement = document.getElementById('speedMode');
                const startElement = document.getElementById('startScreen');
                
                if (scoreElement) scoreElement.textContent = gameState.score;
                if (hpElement) hpElement.textContent = gameState.hp;
                if (levelElement) levelElement.textContent = gameState.level;
                if (stageElement) stageElement.textContent = stages[gameState.currentStage]?.name || 'Unknown';
                if (weaponElement) weaponElement.textContent = weaponNames[gameState.weaponLevel] || 'Unknown';
                if (laserElement) laserElement.textContent = gameState.laserAmmo;
                if (gameOverElement) gameOverElement.style.display = gameState.gameOver ? 'block' : 'none';
                if (endingElement) endingElement.style.display = gameState.showEnding ? 'block' : 'none';
                if (continueElement) continueElement.style.display = gameState.showContinue ? 'block' : 'none';
                if (continueCountElement) {
                    const remaining = 5 - gameState.continuesUsed;
                    continueCountElement.textContent = `æ®‹ã‚Šå›æ•°: ${remaining}`;
                }
                if (speedModeElement) {
                    speedModeElement.style.display = gameState.isSpeedMode ? 'block' : 'none';
                }
                if (startElement) {
                    startElement.style.display = !gameState.gameStarted ? 'block' : 'none';
                }
            } catch (e) {
                console.warn('Error updating UI:', e);
            }
        }
        
        function continueGame() {
            try {
                gameState.continuesUsed++;
                gameState.showContinue = false;
                gameState.hp = 60; // HPã‚’60ã«å›å¾©
                gameState.weaponLevel = 1; // æ­¦å™¨ãƒ¬ãƒ™ãƒ«ã¯ãƒªã‚»ãƒƒãƒˆ
                
                // é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰ã‚‚ãƒªã‚»ãƒƒãƒˆ
                gameState.speedModeTimer = 0;
                gameState.isSpeedMode = false;
                
                // å®‰å…¨ãªä½ç½®ã«é…ç½®ï¼ˆå·ã®å¤–ï¼‰
                player.x = canvas.width / 2;
                player.y = canvas.height - 150; // å°‘ã—ä¸Šã«é…ç½®
                
                // å·ãƒã‚§ãƒƒã‚¯ã—ã¦å®‰å…¨ãªä½ç½®ã‚’è¦‹ã¤ã‘ã‚‹
                let safePosition = findSafePosition();
                if (safePosition) {
                    player.x = safePosition.x;
                    player.y = safePosition.y;
                }
                
                // æ•µå¼¾ã‚’å…¨ã¦æ¶ˆå»ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å„ªã—ãï¼‰
                enemyBullets = [];
                
                continueTimer = 0;
            } catch (e) {
                console.error('Error in continue game:', e);
            }
        }
        
        function findSafePosition() {
            // å®‰å…¨ãªä½ç½®ã‚’æ¢ã™ï¼ˆã‚ˆã‚Šå³å¯†ã«ï¼‰
            for (let attempts = 0; attempts < 50; attempts++) {
                let testX = 60 + Math.random() * (canvas.width - 120 - player.width);
                let testY = canvas.height - 300 + Math.random() * 200;
                
                // å¢ƒç•Œãƒã‚§ãƒƒã‚¯
                if (testX < 50 || testX + player.width > canvas.width - 50) continue;
                if (testY < 0 || testY + player.height > canvas.height) continue;
                
                if (!checkPlayerInRiverAtPosition(testX, testY)) {
                    return { x: testX, y: testY };
                }
            }
            // æœ€çµ‚æ‰‹æ®µï¼šç”»é¢ä¸­å¤®ä¸‹éƒ¨ï¼ˆé€šå¸¸ã¯è‰åŸï¼‰
            return { x: canvas.width / 2 - player.width / 2, y: canvas.height - 150 };
        }
        
        function restartGame() {
            try {
                gameState = {
                    score: 0, hp: 60, level: 1, gameOver: false, gameStarted: false, scrollSpeed: 0.2, enemySpawnRate: 0.008, powerUpSpawnRate: 0.005,
                    backgroundOffset: 0, weaponLevel: 1, bossActive: false, totalDistance: 0, nextBossDistance: 5000, laserAmmo: 10,
                    currentStage: 0, bossesDefeated: 0, gameCleared: false, showEnding: false, continuesUsed: 0, showContinue: false,
                    speedModeTimer: 0, isSpeedMode: false, lastRowWasRiver: false
                };
                
                continueTimer = 0;
                startMusicTimer = 0;
                
                player.x = canvas.width / 2;
                player.y = canvas.height - 120;
                player.width = 36;  // 0.5625å€ã‚µã‚¤ã‚ºã«ä¿®æ­£
                player.height = 36; // 0.5625å€ã‚µã‚¤ã‚ºã«ä¿®æ­£
                player.footLOffset = 0;
                player.footROffset = 0;
                player.footLForward = 0;
                player.footRForward = 0;
                player.bodyBounce = 0;
                player.armLOffset = 0;
                player.armROffset = 0;
                player.headBob = 0;
                player.facingDirection = 1;
                player.lastDirection = 0;
                player.walkFrame = 0;
                player.shootCooldown = 0;
                
                bullets = [];
                enemies = [];
                powerUps = [];
                particles = [];
                questionBoxes = [];
                bosses = [];
                enemyBullets = [];
                
                isBossMusic = false;
                isStartMusic = false;
                isVictoryMusic = false;
                
                initializeBackground();
            } catch (e) {
                console.error('Error restarting game:', e);
                // æœ€å°é™ã®ãƒªã‚»ãƒƒãƒˆ
                gameState.gameOver = false;
                gameState.showEnding = false;
                gameState.gameStarted = false;
                player.x = canvas.width / 2;
                player.y = canvas.height - 120;
            }
        }
        
        function gameLoop() {
            try {
                if (gameState.gameStarted && !gameState.gameOver && !gameState.showContinue) {
                    updatePlayer();
                    updateBullets();
                    updateEnemyBullets();
                    spawnEnemy();
                    spawnQuestionBox();
                    updateEnemies();
                    updateQuestionBoxes();
                    updateBosses();
                    updatePowerUps();
                    updateParticles();
                    updateBackground();
                    updateLevel();
                    checkBossSpawn();
                }
                
                // ã‚³ãƒ³ãƒ†ã‚£ãƒ‹ãƒ¥ãƒ¼ã‚¿ã‚¤ãƒãƒ¼å‡¦ç†
                if (gameState.showContinue) {
                    continueTimer--;
                    if (continueTimer <= 0) {
                        gameState.gameOver = true;
                        gameState.showContinue = false;
                    }
                }
                
                draw();
                updateUI();
            } catch (e) {
                console.error('Error in game loop:', e);
                // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã¯å®‰å…¨ãªçŠ¶æ…‹ã§ã‚²ãƒ¼ãƒ ã‚’ç¶šè¡Œ
            }
            requestAnimationFrame(gameLoop);
        }
        
        gameLoop();
        
        document.addEventListener('click', async () => {
            if (!musicStarted) {
                await initializeMusic();
            }
        }, { once: true });
        
        document.addEventListener('keydown', async (e) => {
            if (!musicStarted) {
                await initializeMusic();
            }
        }, { once: true });
        
        document.addEventListener('keydown', async (e) => {
            if (e.code === 'Space' && !musicStarted) {
                await initializeMusic();
            }
        });
    </script>
</body>
</html>